<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReactivePlusPlus: Utility Operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ReactivePlusPlus
   </div>
   <div id="projectbrief">One more implementation of ReactiveX approach in C++ with care about performance and templates in mind</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__utility__operators.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Utility Operators<div class="ingroups"><a class="el" href="group__rpp.html">RPP</a> &raquo; <a class="el" href="group__operators.html">Operators</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Utility operators are operators that provide some extra functionality without changing of original values, but changing of behaviour.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9df008c11eeff8c9383e56bf36e28ec2" id="r_ga9df008c11eeff8c9383e56bf36e28ec2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9df008c11eeff8c9383e56bf36e28ec2">rpp::operators::as_blocking</a> ()</td></tr>
<tr class="memdesc:ga9df008c11eeff8c9383e56bf36e28ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code><a class="el" href="classrpp_1_1observable.html" title="Base class for any observable used in RPP. It handles core callbacks of observable.">rpp::observable</a></code> to <code><a class="el" href="classrpp_1_1blocking__observable.html" title="Extension over rpp::observable with set of blocking operators - it waits till completion of underlyin...">rpp::blocking_observable</a></code>  <br /></td></tr>
<tr class="separator:ga9df008c11eeff8c9383e56bf36e28ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49e91c6114f62ac261303814c818face" id="r_ga49e91c6114f62ac261303814c818face"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> Scheduler&gt; </td></tr>
<tr class="memitem:ga49e91c6114f62ac261303814c818face"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga49e91c6114f62ac261303814c818face">rpp::operators::debounce</a> (rpp::schedulers::duration period, Scheduler &amp;&amp;scheduler)</td></tr>
<tr class="memdesc:ga49e91c6114f62ac261303814c818face"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only emit emission if specified period of time has passed without any other emission. On each new emission timer reset.  <br /></td></tr>
<tr class="separator:ga49e91c6114f62ac261303814c818face"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38caa489cf43c0aca1aa1c8822aed60" id="r_gae38caa489cf43c0aca1aa1c8822aed60"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> Scheduler&gt; </td></tr>
<tr class="memitem:gae38caa489cf43c0aca1aa1c8822aed60"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae38caa489cf43c0aca1aa1c8822aed60">rpp::operators::delay</a> (rpp::schedulers::duration delay_duration, Scheduler &amp;&amp;scheduler)</td></tr>
<tr class="memdesc:gae38caa489cf43c0aca1aa1c8822aed60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the emissions from an Observable forward in time by a particular amount.  <br /></td></tr>
<tr class="separator:gae38caa489cf43c0aca1aa1c8822aed60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd8305b11ea1d88fc9e128ebbeeb354" id="r_ga8fd8305b11ea1d88fc9e128ebbeeb354"><td class="memTemplParams" colspan="2">template&lt;rpp::constraint::is_nothrow_invocable LastFn&gt; </td></tr>
<tr class="memitem:ga8fd8305b11ea1d88fc9e128ebbeeb354"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8fd8305b11ea1d88fc9e128ebbeeb354">rpp::operators::finally</a> (LastFn &amp;&amp;last_fn)</td></tr>
<tr class="memdesc:ga8fd8305b11ea1d88fc9e128ebbeeb354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callback to be called when execution is done and disposable bound to observer is disposed.  <br /></td></tr>
<tr class="separator:ga8fd8305b11ea1d88fc9e128ebbeeb354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3feb1b1258c7e3e72c151abf176c30c4" id="r_ga3feb1b1258c7e3e72c151abf176c30c4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> Scheduler&gt; </td></tr>
<tr class="memitem:ga3feb1b1258c7e3e72c151abf176c30c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3feb1b1258c7e3e72c151abf176c30c4">rpp::operators::observe_on</a> (Scheduler &amp;&amp;scheduler, rpp::schedulers::duration delay_duration)</td></tr>
<tr class="memdesc:ga3feb1b1258c7e3e72c151abf176c30c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the Scheduler on which an observer will observe this Observable.  <br /></td></tr>
<tr class="separator:ga3feb1b1258c7e3e72c151abf176c30c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96a3c17903a50c2f6dfd66d8b90a96f2" id="r_ga96a3c17903a50c2f6dfd66d8b90a96f2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga96a3c17903a50c2f6dfd66d8b90a96f2">rpp::operators::repeat</a> (size_t count)</td></tr>
<tr class="memdesc:ga96a3c17903a50c2f6dfd66d8b90a96f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats the Observabe's sequence of emissions <code>count</code> times via re-subscribing on it during <code>on_completed</code> call while <code>count</code> not reached.  <br /></td></tr>
<tr class="separator:ga96a3c17903a50c2f6dfd66d8b90a96f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ef49dc75a3eadb0eb3fda7c3692c40" id="r_ga41ef49dc75a3eadb0eb3fda7c3692c40"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga41ef49dc75a3eadb0eb3fda7c3692c40">rpp::operators::repeat</a> ()</td></tr>
<tr class="memdesc:ga41ef49dc75a3eadb0eb3fda7c3692c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats the Observabe's sequence of emissions infinite amount of times via re-subscribing on it during <code>on_completed</code>.  <br /></td></tr>
<tr class="separator:ga41ef49dc75a3eadb0eb3fda7c3692c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga149309d4b2e0f1201f1ab42597ace8ac" id="r_ga149309d4b2e0f1201f1ab42597ace8ac"><td class="memTemplParams" colspan="2">template&lt;rpp::constraint::decayed_type Type, <a class="el" href="conceptrpp_1_1constraint_1_1observer__strategy.html">rpp::constraint::observer_strategy</a>&lt; Type &gt; ObserverStrategy&gt; </td></tr>
<tr class="memitem:ga149309d4b2e0f1201f1ab42597ace8ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a> (<a class="el" href="classrpp_1_1observer.html">observer</a>&lt; Type, ObserverStrategy &gt; &amp;&amp;<a class="el" href="classrpp_1_1observer.html">observer</a>)</td></tr>
<tr class="memdesc:ga149309d4b2e0f1201f1ab42597ace8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes passed observer to emissions from this observable.  <br /></td></tr>
<tr class="separator:ga149309d4b2e0f1201f1ab42597ace8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879876e1f0a7a421d4153224e144ba88" id="r_ga879876e1f0a7a421d4153224e144ba88"><td class="memTemplParams" colspan="2">template&lt;rpp::constraint::decayed_type Type, <a class="el" href="conceptrpp_1_1constraint_1_1observer__strategy.html">rpp::constraint::observer_strategy</a>&lt; Type &gt; ObserverStrategy&gt; </td></tr>
<tr class="memitem:ga879876e1f0a7a421d4153224e144ba88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga879876e1f0a7a421d4153224e144ba88">rpp::operators::subscribe</a> (<a class="el" href="group__disposables.html#ga310f07bbdbf66ad978e748209bfea420">rpp::composite_disposable_wrapper</a> disposable, <a class="el" href="classrpp_1_1observer.html">observer</a>&lt; Type, ObserverStrategy &gt; &amp;&amp;<a class="el" href="classrpp_1_1observer.html">observer</a>)</td></tr>
<tr class="memdesc:ga879876e1f0a7a421d4153224e144ba88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe passed observer to emissions from observable.  <br /></td></tr>
<tr class="separator:ga879876e1f0a7a421d4153224e144ba88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5f97d436e04e578406fc86af36cab79" id="r_gac5f97d436e04e578406fc86af36cab79"><td class="memTemplParams" colspan="2"><a id="gac5f97d436e04e578406fc86af36cab79" name="gac5f97d436e04e578406fc86af36cab79"></a>
template&lt;rpp::constraint::decayed_type Type&gt; </td></tr>
<tr class="memitem:gac5f97d436e04e578406fc86af36cab79"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rpp::operators::subscribe</b> (<a class="el" href="classrpp_1_1dynamic__observer.html">dynamic_observer</a>&lt; Type &gt; <a class="el" href="classrpp_1_1observer.html">observer</a>)</td></tr>
<tr class="memdesc:gac5f97d436e04e578406fc86af36cab79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes passed observer to emissions from this observable. <br /></td></tr>
<tr class="separator:gac5f97d436e04e578406fc86af36cab79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0feb478d994eb22d20dc4f66b340bddc" id="r_ga0feb478d994eb22d20dc4f66b340bddc"><td class="memTemplParams" colspan="2"><a id="ga0feb478d994eb22d20dc4f66b340bddc" name="ga0feb478d994eb22d20dc4f66b340bddc"></a>
template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observer__strategy__base.html">rpp::constraint::observer_strategy_base</a> ObserverStrategy&gt; <br />
requires (!constraint::observer&lt;ObserverStrategy&gt;)</td></tr>
<tr class="memitem:ga0feb478d994eb22d20dc4f66b340bddc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rpp::operators::subscribe</b> (ObserverStrategy &amp;&amp;observer_strategy)</td></tr>
<tr class="memdesc:ga0feb478d994eb22d20dc4f66b340bddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes passed observer strategy to emissions from this observable via construction of observer. <br /></td></tr>
<tr class="separator:ga0feb478d994eb22d20dc4f66b340bddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47528e3e0556c51cfb24722be454179" id="r_gaf47528e3e0556c51cfb24722be454179"><td class="memTemplParams" colspan="2">template&lt;rpp::constraint::decayed_type Type&gt; </td></tr>
<tr class="memitem:gaf47528e3e0556c51cfb24722be454179"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf47528e3e0556c51cfb24722be454179">rpp::operators::subscribe</a> (<a class="el" href="group__disposables.html#ga310f07bbdbf66ad978e748209bfea420">rpp::composite_disposable_wrapper</a> disposable, <a class="el" href="classrpp_1_1dynamic__observer.html">dynamic_observer</a>&lt; Type &gt; <a class="el" href="classrpp_1_1observer.html">observer</a>)</td></tr>
<tr class="memdesc:gaf47528e3e0556c51cfb24722be454179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe passed observer to emissions from observable.  <br /></td></tr>
<tr class="separator:gaf47528e3e0556c51cfb24722be454179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac133e42caad03b922fc95722ef064264" id="r_gac133e42caad03b922fc95722ef064264"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observer__strategy__base.html">rpp::constraint::observer_strategy_base</a> ObserverStrategy&gt; <br />
requires (!constraint::observer&lt;ObserverStrategy&gt;)</td></tr>
<tr class="memitem:gac133e42caad03b922fc95722ef064264"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac133e42caad03b922fc95722ef064264">rpp::operators::subscribe</a> (<a class="el" href="group__disposables.html#ga310f07bbdbf66ad978e748209bfea420">rpp::composite_disposable_wrapper</a> disposable, ObserverStrategy &amp;&amp;observer_strategy)</td></tr>
<tr class="memdesc:gac133e42caad03b922fc95722ef064264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes passed observer strategy to emissions from this observable via construction of observer.  <br /></td></tr>
<tr class="separator:gac133e42caad03b922fc95722ef064264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6344f4f85f89533d2409450774a91843" id="r_ga6344f4f85f89533d2409450774a91843"><td class="memTemplParams" colspan="2"><a id="ga6344f4f85f89533d2409450774a91843" name="ga6344f4f85f89533d2409450774a91843"></a>
template&lt;details::on_next_like OnNext = rpp::utils::empty_function_any_t, std::invocable&lt; const std::exception_ptr &amp; &gt; OnError = rpp::utils::rethrow_error_t, std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga6344f4f85f89533d2409450774a91843"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rpp::operators::subscribe</b> (OnNext &amp;&amp;on_next={}, OnError &amp;&amp;on_error={}, OnCompleted &amp;&amp;on_completed={})</td></tr>
<tr class="memdesc:ga6344f4f85f89533d2409450774a91843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="group__observers.html#ga76d808086fac28fdb0b00fc7513c741a" title="Observer specialized with passed callbacks. Most easiesest way to construct observer &quot;on the fly&quot; via...">rpp::lambda_observer</a> on the fly and subscribe it to emissions from observable. <br /></td></tr>
<tr class="separator:ga6344f4f85f89533d2409450774a91843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63eedc79b749254d053bf124cdc1bba4" id="r_ga63eedc79b749254d053bf124cdc1bba4"><td class="memTemplParams" colspan="2"><a id="ga63eedc79b749254d053bf124cdc1bba4" name="ga63eedc79b749254d053bf124cdc1bba4"></a>
template&lt;details::on_next_like OnNext, std::invocable&lt;&gt; OnCompleted&gt; </td></tr>
<tr class="memitem:ga63eedc79b749254d053bf124cdc1bba4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rpp::operators::subscribe</b> (OnNext &amp;&amp;on_next, OnCompleted &amp;&amp;on_completed)</td></tr>
<tr class="memdesc:ga63eedc79b749254d053bf124cdc1bba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="group__observers.html#ga76d808086fac28fdb0b00fc7513c741a" title="Observer specialized with passed callbacks. Most easiesest way to construct observer &quot;on the fly&quot; via...">rpp::lambda_observer</a> on the fly and subscribe it to emissions from observable. <br /></td></tr>
<tr class="separator:ga63eedc79b749254d053bf124cdc1bba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b742d7c99c0f577e5a6467c826384f7" id="r_ga5b742d7c99c0f577e5a6467c826384f7"><td class="memTemplParams" colspan="2">template&lt;details::on_next_like OnNext = rpp::utils::empty_function_any_t, std::invocable&lt; const std::exception_ptr &amp; &gt; OnError = rpp::utils::rethrow_error_t, std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga5b742d7c99c0f577e5a6467c826384f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5b742d7c99c0f577e5a6467c826384f7">rpp::operators::subscribe</a> (<a class="el" href="group__disposables.html#ga310f07bbdbf66ad978e748209bfea420">rpp::composite_disposable_wrapper</a> d, OnNext &amp;&amp;on_next={}, OnError &amp;&amp;on_error={}, OnCompleted &amp;&amp;on_completed={})</td></tr>
<tr class="memdesc:ga5b742d7c99c0f577e5a6467c826384f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="group__observers.html#ga76d808086fac28fdb0b00fc7513c741a" title="Observer specialized with passed callbacks. Most easiesest way to construct observer &quot;on the fly&quot; via...">rpp::lambda_observer</a> on the fly and subscribe it to emissions from observable.  <br /></td></tr>
<tr class="separator:ga5b742d7c99c0f577e5a6467c826384f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0966f5805b841c809c47a797bfc0e2f5" id="r_ga0966f5805b841c809c47a797bfc0e2f5"><td class="memTemplParams" colspan="2">template&lt;details::on_next_like OnNext, std::invocable&lt;&gt; OnCompleted&gt; </td></tr>
<tr class="memitem:ga0966f5805b841c809c47a797bfc0e2f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0966f5805b841c809c47a797bfc0e2f5">rpp::operators::subscribe</a> (<a class="el" href="group__disposables.html#ga310f07bbdbf66ad978e748209bfea420">rpp::composite_disposable_wrapper</a> d, OnNext &amp;&amp;on_next, OnCompleted &amp;&amp;on_completed)</td></tr>
<tr class="memdesc:ga0966f5805b841c809c47a797bfc0e2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="group__observers.html#ga76d808086fac28fdb0b00fc7513c741a" title="Observer specialized with passed callbacks. Most easiesest way to construct observer &quot;on the fly&quot; via...">rpp::lambda_observer</a> on the fly and subscribe it to emissions from observable.  <br /></td></tr>
<tr class="separator:ga0966f5805b841c809c47a797bfc0e2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d5522fa0644d34943fee364429677fd" id="r_ga8d5522fa0644d34943fee364429677fd"><td class="memTemplParams" colspan="2">template&lt;rpp::constraint::decayed_type Type, <a class="el" href="conceptrpp_1_1constraint_1_1observer__strategy.html">rpp::constraint::observer_strategy</a>&lt; Type &gt; ObserverStrategy&gt; </td></tr>
<tr class="memitem:ga8d5522fa0644d34943fee364429677fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8d5522fa0644d34943fee364429677fd">rpp::operators::subscribe_with_disposable</a> (<a class="el" href="classrpp_1_1observer.html">observer</a>&lt; Type, ObserverStrategy &gt; &amp;&amp;<a class="el" href="classrpp_1_1observer.html">observer</a>)</td></tr>
<tr class="memdesc:ga8d5522fa0644d34943fee364429677fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes passed observer to emissions from this observable.  <br /></td></tr>
<tr class="separator:ga8d5522fa0644d34943fee364429677fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a523ff5b8bccc9e4e8d9e477e8cf90" id="r_ga33a523ff5b8bccc9e4e8d9e477e8cf90"><td class="memTemplParams" colspan="2">template&lt;rpp::constraint::decayed_type Type&gt; </td></tr>
<tr class="memitem:ga33a523ff5b8bccc9e4e8d9e477e8cf90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga33a523ff5b8bccc9e4e8d9e477e8cf90">rpp::operators::subscribe_with_disposable</a> (<a class="el" href="classrpp_1_1dynamic__observer.html">dynamic_observer</a>&lt; Type &gt; <a class="el" href="classrpp_1_1observer.html">observer</a>)</td></tr>
<tr class="memdesc:ga33a523ff5b8bccc9e4e8d9e477e8cf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes passed observer to emissions from this observable.  <br /></td></tr>
<tr class="separator:ga33a523ff5b8bccc9e4e8d9e477e8cf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac87a7d53a94e23c8e444a431a2473a33" id="r_gac87a7d53a94e23c8e444a431a2473a33"><td class="memTemplParams" colspan="2">template&lt;details::on_next_like OnNext = rpp::utils::empty_function_any_t, std::invocable&lt; const std::exception_ptr &amp; &gt; OnError = rpp::utils::rethrow_error_t, std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; </td></tr>
<tr class="memitem:gac87a7d53a94e23c8e444a431a2473a33"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac87a7d53a94e23c8e444a431a2473a33">rpp::operators::subscribe_with_disposable</a> (OnNext &amp;&amp;on_next={}, OnError &amp;&amp;on_error={}, OnCompleted &amp;&amp;on_completed={})</td></tr>
<tr class="memdesc:gac87a7d53a94e23c8e444a431a2473a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="group__observers.html#ga76d808086fac28fdb0b00fc7513c741a" title="Observer specialized with passed callbacks. Most easiesest way to construct observer &quot;on the fly&quot; via...">rpp::lambda_observer</a> on the fly and subscribe it to emissions from observable.  <br /></td></tr>
<tr class="separator:gac87a7d53a94e23c8e444a431a2473a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c527da45630e08a1ee2a9bad47d562d" id="r_ga6c527da45630e08a1ee2a9bad47d562d"><td class="memTemplParams" colspan="2">template&lt;details::on_next_like OnNext, std::invocable&lt;&gt; OnCompleted&gt; </td></tr>
<tr class="memitem:ga6c527da45630e08a1ee2a9bad47d562d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6c527da45630e08a1ee2a9bad47d562d">rpp::operators::subscribe_with_disposable</a> (OnNext &amp;&amp;on_next, OnCompleted &amp;&amp;on_completed)</td></tr>
<tr class="memdesc:ga6c527da45630e08a1ee2a9bad47d562d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="group__observers.html#ga76d808086fac28fdb0b00fc7513c741a" title="Observer specialized with passed callbacks. Most easiesest way to construct observer &quot;on the fly&quot; via...">rpp::lambda_observer</a> on the fly and subscribe it to emissions from observable.  <br /></td></tr>
<tr class="separator:ga6c527da45630e08a1ee2a9bad47d562d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace728cfbf71720901cb6f310edabf8b0" id="r_gace728cfbf71720901cb6f310edabf8b0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> Scheduler&gt; </td></tr>
<tr class="memitem:gace728cfbf71720901cb6f310edabf8b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gace728cfbf71720901cb6f310edabf8b0">rpp::operators::subscribe_on</a> (Scheduler &amp;&amp;scheduler)</td></tr>
<tr class="memdesc:gace728cfbf71720901cb6f310edabf8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">OnSubscribe function for this observable will be scheduled via provided scheduler.  <br /></td></tr>
<tr class="separator:gace728cfbf71720901cb6f310edabf8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1730e4d7f0298c4e50e224041a695a16" id="r_ga1730e4d7f0298c4e50e224041a695a16"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; const std::exception_ptr &amp; &gt; OnError = rpp::utils::empty_function_t&lt;std::exception_ptr&gt;&gt; <br />
requires utils::is_not_template_callable&lt;OnError&gt;</td></tr>
<tr class="memitem:ga1730e4d7f0298c4e50e224041a695a16"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1730e4d7f0298c4e50e224041a695a16">rpp::operators::tap</a> (OnError &amp;&amp;on_error)</td></tr>
<tr class="memdesc:ga1730e4d7f0298c4e50e224041a695a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callbacks to inspect observable emissions and perform side-effects.  <br /></td></tr>
<tr class="separator:ga1730e4d7f0298c4e50e224041a695a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4278374427b8cb7d2e69de046ed5a4c9" id="r_ga4278374427b8cb7d2e69de046ed5a4c9"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga4278374427b8cb7d2e69de046ed5a4c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4278374427b8cb7d2e69de046ed5a4c9">rpp::operators::tap</a> (OnCompleted &amp;&amp;on_completed)</td></tr>
<tr class="memdesc:ga4278374427b8cb7d2e69de046ed5a4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callbacks to inspect observable emissions and perform side-effects.  <br /></td></tr>
<tr class="separator:ga4278374427b8cb7d2e69de046ed5a4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b6a728431216d1eabf2074616667fe" id="r_ga93b6a728431216d1eabf2074616667fe"><td class="memTemplParams" colspan="2">template&lt;typename OnNext , std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga93b6a728431216d1eabf2074616667fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga93b6a728431216d1eabf2074616667fe">rpp::operators::tap</a> (OnNext &amp;&amp;on_next, OnCompleted &amp;&amp;on_completed)</td></tr>
<tr class="memdesc:ga93b6a728431216d1eabf2074616667fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callbacks to inspect observable emissions and perform side-effects.  <br /></td></tr>
<tr class="separator:ga93b6a728431216d1eabf2074616667fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6b3aa896ef87213836a70500d53be0" id="r_gada6b3aa896ef87213836a70500d53be0"><td class="memTemplParams" colspan="2">template&lt;typename OnNext  = rpp::utils::empty_function_any_t, std::invocable&lt; const std::exception_ptr &amp; &gt; OnError = rpp::utils::empty_function_t&lt;std::exception_ptr&gt;, std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; <br />
requires utils::is_not_template_callable&lt;OnError&gt;</td></tr>
<tr class="memitem:gada6b3aa896ef87213836a70500d53be0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gada6b3aa896ef87213836a70500d53be0">rpp::operators::tap</a> (OnNext &amp;&amp;on_next, OnError &amp;&amp;on_error, OnCompleted &amp;&amp;on_completed)</td></tr>
<tr class="memdesc:gada6b3aa896ef87213836a70500d53be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callbacks to inspect observable emissions and perform side-effects.  <br /></td></tr>
<tr class="separator:gada6b3aa896ef87213836a70500d53be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa758f1ad38da6b37357232317fcdc9b5" id="r_gaa758f1ad38da6b37357232317fcdc9b5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TFallbackObservable, <a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> TScheduler&gt; </td></tr>
<tr class="memitem:gaa758f1ad38da6b37357232317fcdc9b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa758f1ad38da6b37357232317fcdc9b5">rpp::operators::timeout</a> (rpp::schedulers::duration period, TFallbackObservable &amp;&amp;fallback_observable, const TScheduler &amp;scheduler)</td></tr>
<tr class="memdesc:gaa758f1ad38da6b37357232317fcdc9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards emissions from original observable, but subscribes on fallback observable if no any events during specified period of time (since last emission)  <br /></td></tr>
<tr class="separator:gaa758f1ad38da6b37357232317fcdc9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c63b0f0f0eae7e2ce0c4789569b9a7" id="r_ga08c63b0f0f0eae7e2ce0c4789569b9a7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> TScheduler&gt; </td></tr>
<tr class="memitem:ga08c63b0f0f0eae7e2ce0c4789569b9a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga08c63b0f0f0eae7e2ce0c4789569b9a7">rpp::operators::timeout</a> (rpp::schedulers::duration period, const TScheduler &amp;scheduler)</td></tr>
<tr class="memdesc:ga08c63b0f0f0eae7e2ce0c4789569b9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards emissions from original observable, but emit error if no any events during specified period of time (since last emission)  <br /></td></tr>
<tr class="separator:ga08c63b0f0f0eae7e2ce0c4789569b9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Utility operators are operators that provide some extra functionality without changing of original values, but changing of behaviour. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators.html#utility">https://reactivex.io/documentation/operators.html#utility</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9df008c11eeff8c9383e56bf36e28ec2" name="ga9df008c11eeff8c9383e56bf36e28ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9df008c11eeff8c9383e56bf36e28ec2">&#9670;&#160;</a></span>as_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::as_blocking </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code><a class="el" href="classrpp_1_1observable.html" title="Base class for any observable used in RPP. It handles core callbacks of observable.">rpp::observable</a></code> to <code><a class="el" href="classrpp_1_1blocking__observable.html" title="Extension over rpp::observable with set of blocking operators - it waits till completion of underlyin...">rpp::blocking_observable</a></code> </p>
<p><code><a class="el" href="classrpp_1_1blocking__observable.html" title="Extension over rpp::observable with set of blocking operators - it waits till completion of underlyin...">rpp::blocking_observable</a></code> blocks <code>subscribe</code> call till on_completed/on_error happens.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(1)</div>
<div class="line">        | <a class="code hl_function" href="#gae38caa489cf43c0aca1aa1c8822aed60">rpp::operators::delay</a>(std::chrono::seconds{1}, <a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{}) <span class="comment">// &lt;-- emit from another thread with delay</span></div>
<div class="line">        | <a class="code hl_function" href="#ga9df008c11eeff8c9383e56bf36e28ec2">rpp::operators::as_blocking</a>()</div>
<div class="line">        | <a class="code hl_function" href="#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](<span class="keywordtype">int</span>) {}, []() { std::cout &lt;&lt; <span class="stringliteral">&quot;COMPLETED&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="comment">// output: COMPLETED done</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="as_blocking_8cpp-example.html#a3">as_blocking.cpp</a>, <a class="el" href="delay_8cpp-example.html#a3">delay.cpp</a>, <a class="el" href="observe_on_8cpp-example.html#a3">observe_on.cpp</a>, <a class="el" href="subscribe_on_8cpp-example.html#a3">subscribe_on.cpp</a>, <a class="el" href="thread_pool_8cpp-example.html#a5">thread_pool.cpp</a>, and <a class="el" href="timeout_8cpp-example.html#a7">timeout.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga49e91c6114f62ac261303814c818face" name="ga49e91c6114f62ac261303814c818face"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49e91c6114f62ac261303814c818face">&#9670;&#160;</a></span>debounce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> Scheduler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::debounce </td>
          <td>(</td>
          <td class="paramtype">rpp::schedulers::duration</td>          <td class="paramname"><span class="paramname"><em>period</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scheduler &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only emit emission if specified period of time has passed without any other emission. On each new emission timer reset. </p>
<div class="image">
<object type="image/svg+xml" data="debounce.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator resets time of last emission, schedules action to send this emission after specified period if no any new emissions till this moment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>is duration of time should be passed since emission from original observable without any new emissions to emit this emission. </td></tr>
    <tr><td class="paramname">scheduler</td><td>is scheduler used to run timer for debounce</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="debounce_8hpp_source.html">rpp/operators/debounce.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> start = rpp::schedulers::clock_type::now();</div>
<div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(<a class="code hl_class" href="classrpp_1_1schedulers_1_1current__thread.html">rpp::schedulers::current_thread</a>{}, 1, 2, 5, 6, 9, 10)</div>
<div class="line">        | <a class="code hl_function" href="group__transforming__operators.html#ga633883e796101ceeab821e2a4912bd5e">rpp::operators::flat_map</a>([](<span class="keywordtype">int</span> v) {</div>
<div class="line">              <span class="keywordflow">return</span> <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(v) | <a class="code hl_function" href="#gae38caa489cf43c0aca1aa1c8822aed60">rpp::operators::delay</a>(std::chrono::milliseconds(500) * v, <a class="code hl_class" href="classrpp_1_1schedulers_1_1current__thread.html">rpp::schedulers::current_thread</a>{});</div>
<div class="line">          })</div>
<div class="line">        | <a class="code hl_function" href="group__filtering__operators.html#ga3ad579153e7975af6ae4b75f585fb873">rpp::operators::filter</a>([&amp;](<span class="keywordtype">int</span> v) {</div>
<div class="line">              std::cout &lt;&lt; <span class="stringliteral">&quot;&gt; Sent value &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(rpp::schedulers::clock_type::now() - start).count() &lt;&lt; std::endl;</div>
<div class="line">              <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">          })</div>
<div class="line">        | <a class="code hl_function" href="#ga49e91c6114f62ac261303814c818face">rpp::operators::debounce</a>(std::chrono::milliseconds{700}, <a class="code hl_class" href="classrpp_1_1schedulers_1_1current__thread.html">rpp::schedulers::current_thread</a>{})</div>
<div class="line">        | <a class="code hl_function" href="#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([&amp;](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt;&gt; new value &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(rpp::schedulers::clock_type::now() - start).count() &lt;&lt; std::endl; },</div>
<div class="line">                                    [](<span class="keyword">const</span> std::exception_ptr&amp;) {},</div>
<div class="line">                                    [&amp;]() { std::cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt;&gt; completed at &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(rpp::schedulers::clock_type::now() - start).count() &lt;&lt; std::endl; });</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// &gt; Sent value 1 at 500</span></div>
<div class="line">    <span class="comment">// &gt; Sent value 2 at 1000</span></div>
<div class="line">    <span class="comment">// &gt;&gt;&gt; new value 2 at 1700</span></div>
<div class="line">    <span class="comment">// &gt; Sent value 5 at 2500</span></div>
<div class="line">    <span class="comment">// &gt; Sent value 6 at 3000</span></div>
<div class="line">    <span class="comment">// &gt;&gt;&gt; new value 6 at 3700</span></div>
<div class="line">    <span class="comment">// &gt; Sent value 9 at 4500</span></div>
<div class="line">    <span class="comment">// &gt; Sent value 10 at 5000</span></div>
<div class="line">    <span class="comment">// &gt;&gt;&gt; new value 10 at 5000</span></div>
<div class="line">    <span class="comment">// &gt;&gt;&gt; completed at 5000</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/debounce.html">https://reactivex.io/documentation/operators/debounce.html</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="debounce_8cpp-example.html#a5">debounce.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gae38caa489cf43c0aca1aa1c8822aed60" name="gae38caa489cf43c0aca1aa1c8822aed60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae38caa489cf43c0aca1aa1c8822aed60">&#9670;&#160;</a></span>delay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> Scheduler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::delay </td>
          <td>(</td>
          <td class="paramtype">rpp::schedulers::duration</td>          <td class="paramname"><span class="paramname"><em>delay_duration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scheduler &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the emissions from an Observable forward in time by a particular amount. </p>
<p>The delay operator modifies its source Observable by pausing for a particular increment of time (that you specify) before emitting each of the source Observable’s items. This has the effect of shifting the entire sequence of items emitted by the Observable forward in time by that specified increment.</p>
<div class="image">
<object type="image/svg+xml" data="delay.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator just schedules emissions via provided scheduler with provided delay_duration. </p><dl class="section warning"><dt>Warning</dt><dd>on_error/on_completed invoking also would be delayed as any other emissions, so, WHOLE observable would be shifter. If you want to obtain <code>on_error</code> immediately, use <code>observe_on</code> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay_duration</td><td>is the delay duration for emitting items. Delay duration should be able to cast to rpp::schedulers::duration. </td></tr>
    <tr><td class="paramname">scheduler</td><td>provides the threading model for delay. e.g. With a new thread scheduler, the observer sees the values in a new thread after a delay duration to the subscription. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="delay_8hpp_source.html">rpp/operators/delay.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> start = rpp::schedulers::clock_type::now();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__creational__operators.html#gae68c87e7ae3a505258b733082bf68513">rpp::source::create&lt;int&gt;</a>([&amp;start](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; obs) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> emitting_time = rpp::schedulers::clock_type::now();</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;emit &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(emitting_time - start).count() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">            obs.on_next(i);</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::seconds{1});</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">auto</span> emitting_time = rpp::schedulers::clock_type::now();</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;emit error in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(emitting_time - start).count() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        obs.on_error({});</div>
<div class="line">    })</div>
<div class="line">        | <a class="code hl_function" href="#gae38caa489cf43c0aca1aa1c8822aed60">rpp::operators::delay</a>(std::chrono::seconds{3}, <a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">        | <a class="code hl_function" href="#ga9df008c11eeff8c9383e56bf36e28ec2">rpp::operators::as_blocking</a>()</div>
<div class="line">        | <a class="code hl_function" href="#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([&amp;](<span class="keywordtype">int</span> v) {</div>
<div class="line">                    <span class="keyword">auto</span> observing_time = rpp::schedulers::clock_type::now();</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;observe &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(observing_time - start).count() &lt;&lt;<span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl; },</div>
<div class="line">                                    [&amp;](<span class="keyword">const</span> std::exception_ptr&amp;) {</div>
<div class="line">                                        <span class="keyword">auto</span> observing_time = rpp::schedulers::clock_type::now();</div>
<div class="line">                                        std::cout &lt;&lt; <span class="stringliteral">&quot;observe error in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(observing_time - start).count() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                                    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Template for output:</span></div>
<div class="line">    <span class="comment">// emit 0 in thread{139855196489600} duration since start 0s</span></div>
<div class="line">    <span class="comment">// emit 1 in thread{139855196489600} duration since start 1s</span></div>
<div class="line">    <span class="comment">// emit 2 in thread{139855196489600} duration since start 2s</span></div>
<div class="line">    <span class="comment">// observe 0 in thread{139855196485184} duration since start 3s</span></div>
<div class="line">    <span class="comment">// emit error in thread{139855196489600} duration since start 3s</span></div>
<div class="line">    <span class="comment">// observe 1 in thread{139855196485184} duration since start 4s</span></div>
<div class="line">    <span class="comment">// observe 2 in thread{139855196485184} duration since start 5s</span></div>
<div class="line">    <span class="comment">// observe error in thread{139855196485184} duration since start 6s</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/delay.html">https://reactivex.io/documentation/operators/delay.html</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="as_blocking_8cpp-example.html#a1">as_blocking.cpp</a>, <a class="el" href="debounce_8cpp-example.html#a3">debounce.cpp</a>, <a class="el" href="delay_8cpp-example.html#a1">delay.cpp</a>, <a class="el" href="thread_pool_8cpp-example.html#a3">thread_pool.cpp</a>, <a class="el" href="throttle_8cpp-example.html#a3">throttle.cpp</a>, and <a class="el" href="timeout_8cpp-example.html#a2">timeout.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga8fd8305b11ea1d88fc9e128ebbeeb354" name="ga8fd8305b11ea1d88fc9e128ebbeeb354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd8305b11ea1d88fc9e128ebbeeb354">&#9670;&#160;</a></span>finally()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rpp::constraint::is_nothrow_invocable LastFn&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::finally </td>
          <td>(</td>
          <td class="paramtype">LastFn &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>last_fn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register callback to be called when execution is done and disposable bound to observer is disposed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">last_fn</td><td>action callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="finally_8hpp_source.html">rpp/operators/finally.hpp</a>&gt;</dd></dl>
<p>action callback needs to be noexcept as it is called on dispose, throwing during this time could potentially break internal disposable state.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga3feb1b1258c7e3e72c151abf176c30c4" name="ga3feb1b1258c7e3e72c151abf176c30c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3feb1b1258c7e3e72c151abf176c30c4">&#9670;&#160;</a></span>observe_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> Scheduler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::observe_on </td>
          <td>(</td>
          <td class="paramtype">Scheduler &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rpp::schedulers::duration</td>          <td class="paramname"><span class="paramname"><em>delay_duration</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the Scheduler on which an observer will observe this Observable. </p>
<p>The observe_on operator modifies its source Observable by emitting all emissions via provided scheduler, so, all emissions/callbacks happens via scheduler.</p>
<div class="image">
<object type="image/svg+xml" data="observe_on.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator is just <code>delay</code>, but in case of obtaining <code>on_error</code> this operator cancels all scheduled but not emited emissions and forward error immediately. In case of you need to delay also <code>on_error</code>, use <code>delay</code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>provides the threading model for delay. e.g. With a new thread scheduler, the observer sees the values in a new thread after a delay duration to the subscription. </td></tr>
    <tr><td class="paramname">delay_duration</td><td>is the delay duration for emitting items. Delay duration should be able to cast to rpp::schedulers::duration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="observe__on_8hpp_source.html">rpp/operators/observe_on.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> start = rpp::schedulers::clock_type::now();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__creational__operators.html#gae68c87e7ae3a505258b733082bf68513">rpp::source::create&lt;int&gt;</a>([&amp;start](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; obs) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> emitting_time = rpp::schedulers::clock_type::now();</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;emit &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(emitting_time - start).count() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">            obs.on_next(i);</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::seconds{1});</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">auto</span> emitting_time = rpp::schedulers::clock_type::now();</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;emit error in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(emitting_time - start).count() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        obs.on_error({});</div>
<div class="line">    })</div>
<div class="line">        | <a class="code hl_function" href="#ga3feb1b1258c7e3e72c151abf176c30c4">rpp::operators::observe_on</a>(<a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{}, std::chrono::seconds{3})</div>
<div class="line">        | <a class="code hl_function" href="#ga9df008c11eeff8c9383e56bf36e28ec2">rpp::operators::as_blocking</a>()</div>
<div class="line">        | <a class="code hl_function" href="#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([&amp;](<span class="keywordtype">int</span> v) {</div>
<div class="line">                    <span class="keyword">auto</span> observing_time = rpp::schedulers::clock_type::now();</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;observe &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(observing_time - start).count() &lt;&lt;<span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl; },</div>
<div class="line">                                    [&amp;](<span class="keyword">const</span> std::exception_ptr&amp;) {</div>
<div class="line">                                        <span class="keyword">auto</span> observing_time = rpp::schedulers::clock_type::now();</div>
<div class="line">                                        std::cout &lt;&lt; <span class="stringliteral">&quot;observe error in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(observing_time - start).count() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                                    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Template for output:</span></div>
<div class="line">    <span class="comment">// emit 0 in thread{139800298538880} duration since start 0s</span></div>
<div class="line">    <span class="comment">// emit 1 in thread{139800298538880} duration since start 1s</span></div>
<div class="line">    <span class="comment">// emit 2 in thread{139800298538880} duration since start 2s</span></div>
<div class="line">    <span class="comment">// observe 0 in thread{139800298534464} duration since start 3s</span></div>
<div class="line">    <span class="comment">// emit error in thread{139800298538880} duration since start 3s</span></div>
<div class="line">    <span class="comment">// observe error in thread{139800298538880} duration since start 3s</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/observeon.html">https://reactivex.io/documentation/operators/observeon.html</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="observe_on_8cpp-example.html#a1">observe_on.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga41ef49dc75a3eadb0eb3fda7c3692c40" name="ga41ef49dc75a3eadb0eb3fda7c3692c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ef49dc75a3eadb0eb3fda7c3692c40">&#9670;&#160;</a></span>repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::repeat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeats the Observabe's sequence of emissions infinite amount of times via re-subscribing on it during <code>on_completed</code>. </p>
<div class="image">
<object type="image/svg+xml" data="repeat_infinitely.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator is kind of <code>concat(obs, obs...)</code></p>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="repeat_8hpp_source.html">rpp/operators/repeat.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples:</dt><dd><div class="fragment"><div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(1, 2, 3)</div>
<div class="line">        | <a class="code hl_function" href="#ga41ef49dc75a3eadb0eb3fda7c3692c40">rpp::operators::repeat</a>()</div>
<div class="line">        | <a class="code hl_function" href="group__filtering__operators.html#gaf32161437c2c6cd7d5a0e5170a333cbb">rpp::operators::take</a>(10)</div>
<div class="line">        | <a class="code hl_function" href="#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; },</div>
<div class="line">                                    [](<span class="keyword">const</span> std::exception_ptr&amp;) {},</div>
<div class="line">                                    []() {</div>
<div class="line">                                        std::cout &lt;&lt; <span class="stringliteral">&quot;completed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                                    });</div>
<div class="line">    <span class="comment">// Output: 1 2 3 1 2 3 1 2 3 1 completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/repeat.html">https://reactivex.io/documentation/operators/repeat.html</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="repeat_8cpp-example.html#a1">repeat.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga96a3c17903a50c2f6dfd66d8b90a96f2" name="ga96a3c17903a50c2f6dfd66d8b90a96f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96a3c17903a50c2f6dfd66d8b90a96f2">&#9670;&#160;</a></span>repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::repeat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeats the Observabe's sequence of emissions <code>count</code> times via re-subscribing on it during <code>on_completed</code> call while <code>count</code> not reached. </p>
<div class="image">
<object type="image/svg+xml" data="repeat.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator is kind of <code>concat(obs, obs...)</code> where obs repeated <code>count</code> times</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>total amount of times subscription happens. For example:<ul>
<li><code>repeat(0)</code> - means no any subscription at all</li>
<li><code>repeat(1)</code> - behave like ordinal observable</li>
<li><code>repeat(10)</code> - 1 normal subscription and 9 re-subscriptions during <code>on_completed</code></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="repeat_8hpp_source.html">rpp/operators/repeat.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples:</dt><dd><div class="fragment"><div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(1, 2, 3)</div>
<div class="line">        | <a class="code hl_function" href="#ga41ef49dc75a3eadb0eb3fda7c3692c40">rpp::operators::repeat</a>(2)</div>
<div class="line">        | <a class="code hl_function" href="#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; },</div>
<div class="line">                                    [](<span class="keyword">const</span> std::exception_ptr&amp;) {},</div>
<div class="line">                                    []() { std::cout &lt;&lt; <span class="stringliteral">&quot;completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output: 1 2 3 1 2 3 completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/repeat.html">https://reactivex.io/documentation/operators/repeat.html</a> </dd></dl>

</div>
</div>
<a id="ga149309d4b2e0f1201f1ab42597ace8ac" name="ga149309d4b2e0f1201f1ab42597ace8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga149309d4b2e0f1201f1ab42597ace8ac">&#9670;&#160;</a></span>subscribe() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rpp::constraint::decayed_type Type, <a class="el" href="conceptrpp_1_1constraint_1_1observer__strategy.html">rpp::constraint::observer_strategy</a>&lt; Type &gt; ObserverStrategy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrpp_1_1observer.html">observer</a>&lt; Type, ObserverStrategy &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribes passed observer to emissions from this observable. </p>
<dl class="section warning"><dt>Warning</dt><dd>Observer must be moved in to subscribe method. (Not recommended) If you need to copy observer, convert it to <a class="el" href="classrpp_1_1dynamic__observer.html" title="Type-erased version of the rpp::observer. Any observer can be converted to dynamic_observer via rpp::...">dynamic_observer</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="as_blocking_8cpp-example.html#a4">as_blocking.cpp</a>, <a class="el" href="concat_8cpp-example.html#a3">concat.cpp</a>, <a class="el" href="debounce_8cpp-example.html#a6">debounce.cpp</a>, <a class="el" href="delay_8cpp-example.html#a4">delay.cpp</a>, <a class="el" href="distinct_until_changed_8cpp-example.html#a2">distinct_until_changed.cpp</a>, <a class="el" href="filter_8cpp-example.html#a2">filter.cpp</a>, <a class="el" href="first_8cpp-example.html#a2">first.cpp</a>, <a class="el" href="group_by_8cpp-example.html#a2">group_by.cpp</a>, <a class="el" href="interval_8cpp-example.html#a3">interval.cpp</a>, <a class="el" href="last_8cpp-example.html#a2">last.cpp</a>, <a class="el" href="map_8cpp-example.html#a2">map.cpp</a>, <a class="el" href="merge_8cpp-example.html#a3">merge.cpp</a>, <a class="el" href="observe_on_8cpp-example.html#a4">observe_on.cpp</a>, <a class="el" href="reduce_8cpp-example.html#a2">reduce.cpp</a>, <a class="el" href="repeat_8cpp-example.html#a2">repeat.cpp</a>, <a class="el" href="retry_8cpp-example.html#a3">retry.cpp</a>, <a class="el" href="retry_when_8cpp-example.html#a3">retry_when.cpp</a>, <a class="el" href="scan_8cpp-example.html#a2">scan.cpp</a>, <a class="el" href="skip_8cpp-example.html#a2">skip.cpp</a>, <a class="el" href="subscribe_on_8cpp-example.html#a4">subscribe_on.cpp</a>, <a class="el" href="switch_on_next_8cpp-example.html#a3">switch_on_next.cpp</a>, <a class="el" href="take_8cpp-example.html#a2">take.cpp</a>, <a class="el" href="take_while_8cpp-example.html#a2">take_while.cpp</a>, <a class="el" href="thread_pool_8cpp-example.html#a6">thread_pool.cpp</a>, <a class="el" href="throttle_8cpp-example.html#a6">throttle.cpp</a>, <a class="el" href="timeout_8cpp-example.html#a8">timeout.cpp</a>, <a class="el" href="window_8cpp-example.html#a2">window.cpp</a>, <a class="el" href="window_toggle_8cpp-example.html#a5">window_toggle.cpp</a>, and <a class="el" href="with_latest_from_8cpp-example.html#a2">with_latest_from.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga0966f5805b841c809c47a797bfc0e2f5" name="ga0966f5805b841c809c47a797bfc0e2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0966f5805b841c809c47a797bfc0e2f5">&#9670;&#160;</a></span>subscribe() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;details::on_next_like OnNext, std::invocable&lt;&gt; OnCompleted&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__disposables.html#ga310f07bbdbf66ad978e748209bfea420">rpp::composite_disposable_wrapper</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnNext &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_next</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnCompleted &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_completed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct <a class="el" href="group__observers.html#ga76d808086fac28fdb0b00fc7513c741a" title="Observer specialized with passed callbacks. Most easiesest way to construct observer &quot;on the fly&quot; via...">rpp::lambda_observer</a> on the fly and subscribe it to emissions from observable. </p>
<p>This overloading attaches passed disposable to observer and return it to provide ability to dispose observer early if needed. </p><dl class="section warning"><dt>Warning</dt><dd>This overloading has some performance penalties, use it only when you really need to use disposable</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is disposable to be attached to observer. If disposable is nullptr or disposed -&gt; no any subscription happens </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b742d7c99c0f577e5a6467c826384f7" name="ga5b742d7c99c0f577e5a6467c826384f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b742d7c99c0f577e5a6467c826384f7">&#9670;&#160;</a></span>subscribe() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;details::on_next_like OnNext = rpp::utils::empty_function_any_t, std::invocable&lt; const std::exception_ptr &amp; &gt; OnError = rpp::utils::rethrow_error_t, std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__disposables.html#ga310f07bbdbf66ad978e748209bfea420">rpp::composite_disposable_wrapper</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnNext &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_next</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnError &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_error</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnCompleted &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_completed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct <a class="el" href="group__observers.html#ga76d808086fac28fdb0b00fc7513c741a" title="Observer specialized with passed callbacks. Most easiesest way to construct observer &quot;on the fly&quot; via...">rpp::lambda_observer</a> on the fly and subscribe it to emissions from observable. </p>
<p>This overloading attaches passed disposable to observer and return it to provide ability to dispose observer early if needed. </p><dl class="section warning"><dt>Warning</dt><dd>This overloading has some performance penalties, use it only when you really need to use disposable</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is disposable to be attached to observer. If disposable is nullptr or disposed -&gt; no any subscription happens </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf47528e3e0556c51cfb24722be454179" name="gaf47528e3e0556c51cfb24722be454179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf47528e3e0556c51cfb24722be454179">&#9670;&#160;</a></span>subscribe() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rpp::constraint::decayed_type Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__disposables.html#ga310f07bbdbf66ad978e748209bfea420">rpp::composite_disposable_wrapper</a></td>          <td class="paramname"><span class="paramname"><em>disposable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrpp_1_1dynamic__observer.html">dynamic_observer</a>&lt; Type &gt;</td>          <td class="paramname"><span class="paramname"><em>observer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe passed observer to emissions from observable. </p>
<p>This overloading attaches passed disposable to observer and return it to provide ability to dispose observer early if needed. </p><dl class="section warning"><dt>Warning</dt><dd>This overloading has some performance penalties, use it only when you really need to use disposable</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is disposable to be attached to observer. If disposable is nullptr or disposed -&gt; no any subscription happens </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga879876e1f0a7a421d4153224e144ba88" name="ga879876e1f0a7a421d4153224e144ba88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879876e1f0a7a421d4153224e144ba88">&#9670;&#160;</a></span>subscribe() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rpp::constraint::decayed_type Type, <a class="el" href="conceptrpp_1_1constraint_1_1observer__strategy.html">rpp::constraint::observer_strategy</a>&lt; Type &gt; ObserverStrategy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__disposables.html#ga310f07bbdbf66ad978e748209bfea420">rpp::composite_disposable_wrapper</a></td>          <td class="paramname"><span class="paramname"><em>disposable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrpp_1_1observer.html">observer</a>&lt; Type, ObserverStrategy &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe passed observer to emissions from observable. </p>
<p>This overloading attaches passed disposable to observer and return it to provide ability to dispose observer early if needed. </p><dl class="section warning"><dt>Warning</dt><dd>This overloading has some performance penalties, use it only when you really need to use disposable</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is disposable to be attached to observer. If disposable is nullptr or disposed -&gt; no any subscription happens </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac133e42caad03b922fc95722ef064264" name="gac133e42caad03b922fc95722ef064264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac133e42caad03b922fc95722ef064264">&#9670;&#160;</a></span>subscribe() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observer__strategy__base.html">rpp::constraint::observer_strategy_base</a> ObserverStrategy&gt; <br />
requires (!constraint::observer&lt;ObserverStrategy&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__disposables.html#ga310f07bbdbf66ad978e748209bfea420">rpp::composite_disposable_wrapper</a></td>          <td class="paramname"><span class="paramname"><em>disposable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObserverStrategy &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observer_strategy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribes passed observer strategy to emissions from this observable via construction of observer. </p>
<p>This overloading attaches passed disposable to observer and return it to provide ability to dispose observer early if needed. </p><dl class="section warning"><dt>Warning</dt><dd>This overloading has some performance penalties, use it only when you really need to use disposable</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is disposable to be attached to observer. If disposable is nullptr or disposed -&gt; no any subscription happens </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gace728cfbf71720901cb6f310edabf8b0" name="gace728cfbf71720901cb6f310edabf8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace728cfbf71720901cb6f310edabf8b0">&#9670;&#160;</a></span>subscribe_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> Scheduler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe_on </td>
          <td>(</td>
          <td class="paramtype">Scheduler &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OnSubscribe function for this observable will be scheduled via provided scheduler. </p>
<p>Actually this operator just schedules subscription on original observable to provided scheduler</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>is scheduler used for scheduling of OnSubscribe </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="subscribe__on_8hpp_source.html">rpp/operators/subscribe_on.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</div>
<div class="line">    <a class="code hl_function" href="group__creational__operators.html#gae68c87e7ae3a505258b733082bf68513">rpp::source::create&lt;int&gt;</a>([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sub) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;on_subscribe thread &quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</div>
<div class="line">        sub.on_next(1);</div>
<div class="line">        sub.on_completed();</div>
<div class="line">    })</div>
<div class="line">        | <a class="code hl_function" href="#gace728cfbf71720901cb6f310edabf8b0">rpp::operators::subscribe_on</a>(<a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">        | <a class="code hl_function" href="#ga9df008c11eeff8c9383e56bf36e28ec2">rpp::operators::as_blocking</a>()</div>
<div class="line">        | <a class="code hl_function" href="#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;] : &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; });</div>
<div class="line">    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Template for output:</span></div>
<div class="line">    <span class="comment">// TH1</span></div>
<div class="line">    <span class="comment">// on_subscribe thread TH2</span></div>
<div class="line">    <span class="comment">// [TH2]: 1</span></div>
<div class="line">    <span class="comment">// TH1</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/subscribeon.html">https://reactivex.io/documentation/operators/subscribeon.html</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="subscribe_on_8cpp-example.html#a1">subscribe_on.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga33a523ff5b8bccc9e4e8d9e477e8cf90" name="ga33a523ff5b8bccc9e4e8d9e477e8cf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33a523ff5b8bccc9e4e8d9e477e8cf90">&#9670;&#160;</a></span>subscribe_with_disposable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rpp::constraint::decayed_type Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe_with_disposable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrpp_1_1dynamic__observer.html">dynamic_observer</a>&lt; Type &gt;</td>          <td class="paramname"><span class="paramname"><em>observer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribes passed observer to emissions from this observable. </p>
<p>This overloading attaches disposable to observer and return it to provide ability to dispose/disconnect observer early if needed. </p><dl class="section warning"><dt>Warning</dt><dd>This overloading has some performance penalties, use it only when you really need to use disposable </dd></dl>

</div>
</div>
<a id="ga8d5522fa0644d34943fee364429677fd" name="ga8d5522fa0644d34943fee364429677fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d5522fa0644d34943fee364429677fd">&#9670;&#160;</a></span>subscribe_with_disposable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rpp::constraint::decayed_type Type, <a class="el" href="conceptrpp_1_1constraint_1_1observer__strategy.html">rpp::constraint::observer_strategy</a>&lt; Type &gt; ObserverStrategy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe_with_disposable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrpp_1_1observer.html">observer</a>&lt; Type, ObserverStrategy &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribes passed observer to emissions from this observable. </p>
<p>This overloading attaches disposable to observer and return it to provide ability to dispose/disconnect observer early if needed. </p><dl class="section warning"><dt>Warning</dt><dd>This overloading has some performance penalties, use it only when you really need to use disposable</dd>
<dd>
Observer must be moved in to subscribe method. (Not recommended) If you need to copy observer, convert it to <a class="el" href="classrpp_1_1dynamic__observer.html" title="Type-erased version of the rpp::observer. Any observer can be converted to dynamic_observer via rpp::...">dynamic_observer</a> </dd></dl>

</div>
</div>
<a id="ga6c527da45630e08a1ee2a9bad47d562d" name="ga6c527da45630e08a1ee2a9bad47d562d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c527da45630e08a1ee2a9bad47d562d">&#9670;&#160;</a></span>subscribe_with_disposable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;details::on_next_like OnNext, std::invocable&lt;&gt; OnCompleted&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe_with_disposable </td>
          <td>(</td>
          <td class="paramtype">OnNext &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_next</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnCompleted &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_completed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct <a class="el" href="group__observers.html#ga76d808086fac28fdb0b00fc7513c741a" title="Observer specialized with passed callbacks. Most easiesest way to construct observer &quot;on the fly&quot; via...">rpp::lambda_observer</a> on the fly and subscribe it to emissions from observable. </p>
<p>This overloading attaches disposable to observer and return it to provide ability to dispose/disconnect observer early if needed. </p><dl class="section warning"><dt>Warning</dt><dd>This overloading has some performance penalties, use it only when you really need to use disposable </dd></dl>

</div>
</div>
<a id="gac87a7d53a94e23c8e444a431a2473a33" name="gac87a7d53a94e23c8e444a431a2473a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac87a7d53a94e23c8e444a431a2473a33">&#9670;&#160;</a></span>subscribe_with_disposable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;details::on_next_like OnNext = rpp::utils::empty_function_any_t, std::invocable&lt; const std::exception_ptr &amp; &gt; OnError = rpp::utils::rethrow_error_t, std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::subscribe_with_disposable </td>
          <td>(</td>
          <td class="paramtype">OnNext &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_next</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnError &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_error</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnCompleted &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_completed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct <a class="el" href="group__observers.html#ga76d808086fac28fdb0b00fc7513c741a" title="Observer specialized with passed callbacks. Most easiesest way to construct observer &quot;on the fly&quot; via...">rpp::lambda_observer</a> on the fly and subscribe it to emissions from observable. </p>
<p>This overloading attaches disposable to observer and return it to provide ability to dispose/disconnect observer early if needed. </p><dl class="section warning"><dt>Warning</dt><dd>This overloading has some performance penalties, use it only when you really need to use disposable </dd></dl>

</div>
</div>
<a id="ga4278374427b8cb7d2e69de046ed5a4c9" name="ga4278374427b8cb7d2e69de046ed5a4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4278374427b8cb7d2e69de046ed5a4c9">&#9670;&#160;</a></span>tap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::tap </td>
          <td>(</td>
          <td class="paramtype">OnCompleted &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_completed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register callbacks to inspect observable emissions and perform side-effects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_completed</td><td>completion handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga1730e4d7f0298c4e50e224041a695a16" name="ga1730e4d7f0298c4e50e224041a695a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1730e4d7f0298c4e50e224041a695a16">&#9670;&#160;</a></span>tap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::invocable&lt; const std::exception_ptr &amp; &gt; OnError = rpp::utils::empty_function_t&lt;std::exception_ptr&gt;&gt; <br />
requires utils::is_not_template_callable&lt;OnError&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::tap </td>
          <td>(</td>
          <td class="paramtype">OnError &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_error</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register callbacks to inspect observable emissions and perform side-effects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_error</td><td>error handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga93b6a728431216d1eabf2074616667fe" name="ga93b6a728431216d1eabf2074616667fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b6a728431216d1eabf2074616667fe">&#9670;&#160;</a></span>tap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OnNext , std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::tap </td>
          <td>(</td>
          <td class="paramtype">OnNext &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_next</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnCompleted &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_completed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register callbacks to inspect observable emissions and perform side-effects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_next</td><td>next handler </td></tr>
    <tr><td class="paramname">on_completed</td><td>completion handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="gada6b3aa896ef87213836a70500d53be0" name="gada6b3aa896ef87213836a70500d53be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada6b3aa896ef87213836a70500d53be0">&#9670;&#160;</a></span>tap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OnNext  = rpp::utils::empty_function_any_t, std::invocable&lt; const std::exception_ptr &amp; &gt; OnError = rpp::utils::empty_function_t&lt;std::exception_ptr&gt;, std::invocable&lt;&gt; OnCompleted = rpp::utils::empty_function_t&lt;&gt;&gt; <br />
requires utils::is_not_template_callable&lt;OnError&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::tap </td>
          <td>(</td>
          <td class="paramtype">OnNext &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_next</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnError &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_error</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnCompleted &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>on_completed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register callbacks to inspect observable emissions and perform side-effects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_next</td><td>next handler </td></tr>
    <tr><td class="paramname">on_error</td><td>error handler </td></tr>
    <tr><td class="paramname">on_completed</td><td>completion handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga08c63b0f0f0eae7e2ce0c4789569b9a7" name="ga08c63b0f0f0eae7e2ce0c4789569b9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c63b0f0f0eae7e2ce0c4789569b9a7">&#9670;&#160;</a></span>timeout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> TScheduler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::timeout </td>
          <td>(</td>
          <td class="paramtype">rpp::schedulers::duration</td>          <td class="paramname"><span class="paramname"><em>period</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TScheduler &amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forwards emissions from original observable, but emit error if no any events during specified period of time (since last emission) </p>
<div class="image">
<object type="image/svg+xml" data="timeout_default.svg" style="pointer-events: none;"></object>
</div>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>is maximum duration between emitted items before a timeout occurs </td></tr>
    <tr><td class="paramname">scheduler</td><td>is scheduler used to run timer for timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="timeout_8hpp_source.html">rpp/operators/timeout.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">        <span class="keyword">auto</span> start = rpp::schedulers::clock_type::now();</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(10, 30, 90, 110)</div>
<div class="line">            | <a class="code hl_function" href="group__transforming__operators.html#ga633883e796101ceeab821e2a4912bd5e">rpp::operators::flat_map</a>([](<span class="keywordtype">int</span> v) {</div>
<div class="line">                  <span class="keywordflow">return</span> <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(v) | <a class="code hl_function" href="#gae38caa489cf43c0aca1aa1c8822aed60">rpp::operators::delay</a>(std::chrono::milliseconds{v}, <a class="code hl_class" href="classrpp_1_1schedulers_1_1current__thread.html">rpp::schedulers::current_thread</a>{});</div>
<div class="line">              })</div>
<div class="line">            | <a class="code hl_function" href="#gaa758f1ad38da6b37357232317fcdc9b5">rpp::operators::timeout</a>(std::chrono::milliseconds{35}, <a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            | <a class="code hl_function" href="#ga9df008c11eeff8c9383e56bf36e28ec2">rpp::operators::as_blocking</a>()</div>
<div class="line">            | <a class="code hl_function" href="#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([start](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;received &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(rpp::schedulers::clock_type::now() - start).count() &lt;&lt; std::endl; },</div>
<div class="line">                                        [start](<span class="keyword">const</span> std::exception_ptr&amp;) {</div>
<div class="line">                                            std::cout &lt;&lt; <span class="stringliteral">&quot;received error at &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(rpp::schedulers::clock_type::now() - start).count() &lt;&lt; std::endl;</div>
<div class="line">                                        });</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/timeout.html">https://reactivex.io/documentation/operators/timeout.html</a> </dd></dl>

</div>
</div>
<a id="gaa758f1ad38da6b37357232317fcdc9b5" name="gaa758f1ad38da6b37357232317fcdc9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa758f1ad38da6b37357232317fcdc9b5">&#9670;&#160;</a></span>timeout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TFallbackObservable, <a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> TScheduler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::timeout </td>
          <td>(</td>
          <td class="paramtype">rpp::schedulers::duration</td>          <td class="paramname"><span class="paramname"><em>period</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFallbackObservable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>fallback_observable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TScheduler &amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forwards emissions from original observable, but subscribes on fallback observable if no any events during specified period of time (since last emission) </p>
<div class="image">
<object type="image/svg+xml" data="timeout_fallback_obs.svg" style="pointer-events: none;"></object>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>is maximum duration between emitted items before a timeout occurs </td></tr>
    <tr><td class="paramname">fallback_observable</td><td>is observable to subscribe on when timeout reached </td></tr>
    <tr><td class="paramname">scheduler</td><td>is scheduler used to run timer for timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="timeout_8hpp_source.html">rpp/operators/timeout.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">        <span class="keyword">auto</span> start = rpp::schedulers::clock_type::now();</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(10, 30, 90, 110)</div>
<div class="line">            | <a class="code hl_function" href="group__transforming__operators.html#ga633883e796101ceeab821e2a4912bd5e">rpp::operators::flat_map</a>([](<span class="keywordtype">int</span> v) {</div>
<div class="line">                  <span class="keywordflow">return</span> <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(v) | <a class="code hl_function" href="#gae38caa489cf43c0aca1aa1c8822aed60">rpp::operators::delay</a>(std::chrono::milliseconds{v}, <a class="code hl_class" href="classrpp_1_1schedulers_1_1current__thread.html">rpp::schedulers::current_thread</a>{});</div>
<div class="line">              })</div>
<div class="line">            | <a class="code hl_function" href="#gaa758f1ad38da6b37357232317fcdc9b5">rpp::operators::timeout</a>(std::chrono::milliseconds{35}, <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(<a class="code hl_class" href="classrpp_1_1schedulers_1_1immediate.html">rpp::schedulers::immediate</a>{}, 0), <a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            | <a class="code hl_function" href="#ga9df008c11eeff8c9383e56bf36e28ec2">rpp::operators::as_blocking</a>()</div>
<div class="line">            | <a class="code hl_function" href="#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([start](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;received &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(rpp::schedulers::clock_type::now() - start).count() &lt;&lt; std::endl; },</div>
<div class="line">                                        [start](<span class="keyword">const</span> std::exception_ptr&amp;) {</div>
<div class="line">                                            std::cout &lt;&lt; <span class="stringliteral">&quot;received error at &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(rpp::schedulers::clock_type::now() - start).count() &lt;&lt; std::endl;</div>
<div class="line">                                        });</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/timeout.html">https://reactivex.io/documentation/operators/timeout.html</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="timeout_8cpp-example.html#a4">timeout.cpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>

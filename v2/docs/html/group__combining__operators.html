<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReactivePlusPlus: Combining Operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ReactivePlusPlus
   </div>
   <div id="projectbrief">One more implementation of ReactiveX approach in C++ with care about performance and templates in mind</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__combining__operators.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Combining Operators<div class="ingroups"><a class="el" href="group__rpp.html">RPP</a> &raquo; <a class="el" href="group__operators.html">Operators</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Combining operators are operators that combines emissions of multiple observables into same observable by some rule.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab241e6bd601f534355a2833d38cfd669" id="r_gab241e6bd601f534355a2833d38cfd669"><td class="memTemplParams" colspan="2">template&lt;typename TSelector , <a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; <br />
requires (!<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a>&lt;TSelector&gt; &amp;&amp; (!utils::is_not_template_callable&lt;TSelector&gt; || std::invocable&lt;TSelector, rpp::utils::convertible_to_any, utils::extract_observable_type_t&lt;TObservable&gt;, utils::extract_observable_type_t&lt;TObservables&gt;...&gt;))</td></tr>
<tr class="memitem:gab241e6bd601f534355a2833d38cfd669"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab241e6bd601f534355a2833d38cfd669">rpp::operators::combine_latest</a> (TSelector &amp;&amp;selector, TObservable &amp;&amp;<a class="el" href="classrpp_1_1observable.html">observable</a>, TObservables &amp;&amp;... observables)</td></tr>
<tr class="memdesc:gab241e6bd601f534355a2833d38cfd669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines latest emissions from observables with emission from current observable when any observable sends new value via applying selector.  <br /></td></tr>
<tr class="separator:gab241e6bd601f534355a2833d38cfd669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c6073a2a2858a3f037a5ec930da33d2" id="r_ga5c6073a2a2858a3f037a5ec930da33d2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; </td></tr>
<tr class="memitem:ga5c6073a2a2858a3f037a5ec930da33d2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5c6073a2a2858a3f037a5ec930da33d2">rpp::operators::combine_latest</a> (TObservable &amp;&amp;<a class="el" href="classrpp_1_1observable.html">observable</a>, TObservables &amp;&amp;... observables)</td></tr>
<tr class="memdesc:ga5c6073a2a2858a3f037a5ec930da33d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines latest emissions from observables with emission from current observable when any observable sends new value via making tuple.  <br /></td></tr>
<tr class="separator:ga5c6073a2a2858a3f037a5ec930da33d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8a04b4c8eb945534eddde5a25eec74" id="r_ga3f8a04b4c8eb945534eddde5a25eec74"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f8a04b4c8eb945534eddde5a25eec74">rpp::operators::merge</a> ()</td></tr>
<tr class="memdesc:ga3f8a04b4c8eb945534eddde5a25eec74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts observable of observables of items into observable of items via merging emissions.  <br /></td></tr>
<tr class="separator:ga3f8a04b4c8eb945534eddde5a25eec74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35392a84e52bf7101d0d0445ef391db7" id="r_ga35392a84e52bf7101d0d0445ef391db7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; <br />
requires constraint::observables_of_same_type&lt;std::decay_t&lt;TObservable&gt;, std::decay_t&lt;TObservables&gt;...&gt;</td></tr>
<tr class="memitem:ga35392a84e52bf7101d0d0445ef391db7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga35392a84e52bf7101d0d0445ef391db7">rpp::operators::merge_with</a> (TObservable &amp;&amp;<a class="el" href="classrpp_1_1observable.html">observable</a>, TObservables &amp;&amp;... observables)</td></tr>
<tr class="memdesc:ga35392a84e52bf7101d0d0445ef391db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines submissions from current observable with other observables into one.  <br /></td></tr>
<tr class="separator:ga35392a84e52bf7101d0d0445ef391db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf12c4de9702425819b0d34b5fdf7db3" id="r_gadf12c4de9702425819b0d34b5fdf7db3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; <br />
requires constraint::observables_of_same_type&lt;std::decay_t&lt;TObservable&gt;, std::decay_t&lt;TObservables&gt;...&gt;</td></tr>
<tr class="memitem:gadf12c4de9702425819b0d34b5fdf7db3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadf12c4de9702425819b0d34b5fdf7db3">rpp::operators::start_with</a> (TObservable &amp;&amp;<a class="el" href="classrpp_1_1observable.html">observable</a>, TObservables &amp;&amp;... observables)</td></tr>
<tr class="memdesc:gadf12c4de9702425819b0d34b5fdf7db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines submissions from current observable with other observables into one but without overlapping and starting from observables provided as arguments.  <br /></td></tr>
<tr class="separator:gadf12c4de9702425819b0d34b5fdf7db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb4fbf5e43b500471881a900ef1d6b9" id="r_ga7bb4fbf5e43b500471881a900ef1d6b9"><td class="memTemplParams" colspan="2">template&lt;constraint::memory_model MemoryModel = memory_model::use_stack, typename T , typename... Ts&gt; <br />
requires (rpp::constraint::decayed_same_as&lt;T, Ts&gt; &amp;&amp; ...)</td></tr>
<tr class="memitem:ga7bb4fbf5e43b500471881a900ef1d6b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7bb4fbf5e43b500471881a900ef1d6b9">rpp::operators::start_with_values</a> (T &amp;&amp;v, Ts &amp;&amp;... vals)</td></tr>
<tr class="memdesc:ga7bb4fbf5e43b500471881a900ef1d6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines submissions from current observable with values into one but without overlapping and starting from values provided as arguments.  <br /></td></tr>
<tr class="separator:ga7bb4fbf5e43b500471881a900ef1d6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a8768b213581b77f025c39c42e1e78" id="r_ga04a8768b213581b77f025c39c42e1e78"><td class="memTemplParams" colspan="2">template&lt;constraint::memory_model MemoryModel = memory_model::use_stack, <a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> TScheduler, typename T , typename... Ts&gt; <br />
requires (rpp::constraint::decayed_same_as&lt;T, Ts&gt; &amp;&amp; ...)</td></tr>
<tr class="memitem:ga04a8768b213581b77f025c39c42e1e78"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga04a8768b213581b77f025c39c42e1e78">rpp::operators::start_with_values</a> (const TScheduler &amp;scheduler, T &amp;&amp;v, Ts &amp;&amp;... vals)</td></tr>
<tr class="memdesc:ga04a8768b213581b77f025c39c42e1e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines submissions from current observable with values into one but without overlapping and starting from values provided as arguments.  <br /></td></tr>
<tr class="separator:ga04a8768b213581b77f025c39c42e1e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga917329dc13be7f4d037a12dcc1a1abe9" id="r_ga917329dc13be7f4d037a12dcc1a1abe9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga917329dc13be7f4d037a12dcc1a1abe9">rpp::operators::switch_on_next</a> ()</td></tr>
<tr class="memdesc:ga917329dc13be7f4d037a12dcc1a1abe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts observable of observables into observable of values which emits values from most recent underlying observable till new observable obtained.  <br /></td></tr>
<tr class="separator:ga917329dc13be7f4d037a12dcc1a1abe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9345ba5faac717ba85fc88f1c5fff58b" id="r_ga9345ba5faac717ba85fc88f1c5fff58b"><td class="memTemplParams" colspan="2">template&lt;typename TSelector , <a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; <br />
requires (!<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a>&lt;TSelector&gt; &amp;&amp; (!utils::is_not_template_callable&lt;TSelector&gt; || std::invocable&lt;TSelector, rpp::utils::convertible_to_any, utils::extract_observable_type_t&lt;TObservable&gt;, utils::extract_observable_type_t&lt;TObservables&gt;...&gt;))</td></tr>
<tr class="memitem:ga9345ba5faac717ba85fc88f1c5fff58b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9345ba5faac717ba85fc88f1c5fff58b">rpp::operators::with_latest_from</a> (TSelector &amp;&amp;selector, TObservable &amp;&amp;<a class="el" href="classrpp_1_1observable.html">observable</a>, TObservables &amp;&amp;... observables)</td></tr>
<tr class="memdesc:ga9345ba5faac717ba85fc88f1c5fff58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines latest emissions from observables with emission from current observable when it sends new value via applying selector.  <br /></td></tr>
<tr class="separator:ga9345ba5faac717ba85fc88f1c5fff58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20acc2f23cb06163f9d5e56c5522ce6c" id="r_ga20acc2f23cb06163f9d5e56c5522ce6c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; </td></tr>
<tr class="memitem:ga20acc2f23cb06163f9d5e56c5522ce6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga20acc2f23cb06163f9d5e56c5522ce6c">rpp::operators::with_latest_from</a> (TObservable &amp;&amp;<a class="el" href="classrpp_1_1observable.html">observable</a>, TObservables &amp;&amp;... observables)</td></tr>
<tr class="memdesc:ga20acc2f23cb06163f9d5e56c5522ce6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines latest emissions from observables with emission from current observable when it sends new value via making tuple.  <br /></td></tr>
<tr class="separator:ga20acc2f23cb06163f9d5e56c5522ce6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e89ade7cae676333672b78db5f1a8b" id="r_gae2e89ade7cae676333672b78db5f1a8b"><td class="memTemplParams" colspan="2">template&lt;typename TSelector , <a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; <br />
requires (!<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a>&lt;TSelector&gt; &amp;&amp; (!utils::is_not_template_callable&lt;TSelector&gt; || std::invocable&lt;TSelector, rpp::utils::convertible_to_any, utils::extract_observable_type_t&lt;TObservable&gt;, utils::extract_observable_type_t&lt;TObservables&gt;...&gt;))</td></tr>
<tr class="memitem:gae2e89ade7cae676333672b78db5f1a8b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae2e89ade7cae676333672b78db5f1a8b">rpp::operators::zip</a> (TSelector &amp;&amp;selector, TObservable &amp;&amp;<a class="el" href="classrpp_1_1observable.html">observable</a>, TObservables &amp;&amp;... observables)</td></tr>
<tr class="memdesc:gae2e89ade7cae676333672b78db5f1a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">combines emissions from observables and emit single items for each combination based on the results of provided selector  <br /></td></tr>
<tr class="separator:gae2e89ade7cae676333672b78db5f1a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f723fc5e197ab21f67b879c5a668d7" id="r_ga83f723fc5e197ab21f67b879c5a668d7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; </td></tr>
<tr class="memitem:ga83f723fc5e197ab21f67b879c5a668d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga83f723fc5e197ab21f67b879c5a668d7">rpp::operators::zip</a> (TObservable &amp;&amp;<a class="el" href="classrpp_1_1observable.html">observable</a>, TObservables &amp;&amp;... observables)</td></tr>
<tr class="memdesc:ga83f723fc5e197ab21f67b879c5a668d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">combines emissions from observables and emit tuple of items for each combination  <br /></td></tr>
<tr class="separator:ga83f723fc5e197ab21f67b879c5a668d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Combining operators are operators that combines emissions of multiple observables into same observable by some rule. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators.html#combining">https://reactivex.io/documentation/operators.html#combining</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5c6073a2a2858a3f037a5ec930da33d2" name="ga5c6073a2a2858a3f037a5ec930da33d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c6073a2a2858a3f037a5ec930da33d2">&#9670;&#160;</a></span>combine_latest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::combine_latest </td>
          <td>(</td>
          <td class="paramtype">TObservable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservables &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>observables</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines latest emissions from observables with emission from current observable when any observable sends new value via making tuple. </p>
<div class="image">
<object type="image/svg+xml" data="combine_latest.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator subscribes on all of theses observables and emits new combined value when any of them emits new emission (and each observable emit values at least one to be able to provide combined value)</p>
<dl class="section warning"><dt>Warning</dt><dd>Selector is just packing values to tuple in this case</dd></dl>
<dl class="section user"><dt>Performance notes:</dt><dd><ul>
<li>1 heap allocation for disposable</li>
<li>each value from any observable copied/moved to internal storage</li>
<li>mutex acquired every time value obtained</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be combined when any observable sends new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="combine__latest_8hpp_source.html">rpp/operators/combine_latest.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(<a class="code hl_class" href="classrpp_1_1schedulers_1_1current__thread.html">rpp::schedulers::current_thread</a>{}, 1, 2, 3)                                 <span class="comment">// source 1</span></div>
<div class="line">        | rpp::ops::combine_latest(<a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(<a class="code hl_class" href="classrpp_1_1schedulers_1_1current__thread.html">rpp::schedulers::current_thread</a>{}, 4, 5, 6)) <span class="comment">// source 2</span></div>
<div class="line">        | rpp::ops::subscribe([](<span class="keyword">const</span> std::tuple&lt;int, int&gt;&amp; v) { std::cout &lt;&lt; <span class="stringliteral">&quot;-&quot;</span> &lt;&lt; v; },</div>
<div class="line">                              [](<span class="keyword">const</span> std::exception_ptr&amp;) {},</div>
<div class="line">                              []() { std::cout &lt;&lt; <span class="stringliteral">&quot;-|&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// source 1:   -1---2---3-|</span></div>
<div class="line">    <span class="comment">// source 2: -4---5---6-| (note that source 2 is subscribed earlier than source 1)</span></div>
<div class="line">    <span class="comment">// Output  : -{1,4}-{1,5}-{2,5}-{2,6}-{3,6}}-|</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/combinelatest.html">https://reactivex.io/documentation/operators/combinelatest.html</a> </dd></dl>

</div>
</div>
<a id="gab241e6bd601f534355a2833d38cfd669" name="gab241e6bd601f534355a2833d38cfd669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab241e6bd601f534355a2833d38cfd669">&#9670;&#160;</a></span>combine_latest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector , <a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; <br />
requires (!<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a>&lt;TSelector&gt; &amp;&amp; (!utils::is_not_template_callable&lt;TSelector&gt; || std::invocable&lt;TSelector, rpp::utils::convertible_to_any, utils::extract_observable_type_t&lt;TObservable&gt;, utils::extract_observable_type_t&lt;TObservables&gt;...&gt;))</div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::combine_latest </td>
          <td>(</td>
          <td class="paramtype">TSelector &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservables &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>observables</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines latest emissions from observables with emission from current observable when any observable sends new value via applying selector. </p>
<div class="image">
<object type="image/svg+xml" data="combine_latest_custom_selector.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator subscribes on all of theses observables and emits new combined value when any of them emits new emission (and each observable emit values at least one to be able to provide combined value)</p>
<dl class="section user"><dt>Performance notes:</dt><dd><ul>
<li>1 heap allocation for disposable</li>
<li>each value from any observable copied/moved to internal storage</li>
<li>mutex acquired every time value obtained</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>is applied to current emission of current observable and latests emissions from observables </td></tr>
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be combined with current observable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="combine__latest_8hpp_source.html">rpp/operators/combine_latest.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"></div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/combinelatest.html">https://reactivex.io/documentation/operators/combinelatest.html</a> </dd></dl>

</div>
</div>
<a id="ga3f8a04b4c8eb945534eddde5a25eec74" name="ga3f8a04b4c8eb945534eddde5a25eec74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f8a04b4c8eb945534eddde5a25eec74">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::merge </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts observable of observables of items into observable of items via merging emissions. </p>
<dl class="section warning"><dt>Warning</dt><dd>According to observable contract (<a href="https://reactivex.io/documentation/contract.html">https://reactivex.io/documentation/contract.html</a>) emissions from any observable should be serialized, so, resulting observable uses mutex to satisfy this requirement</dd>
<dd>
During on subscribe operator takes ownership over <a class="el" href="classrpp_1_1schedulers_1_1current__thread.html" title="Schedules execution of schedulables via queueing tasks to the caller thread with priority to time_poi...">rpp::schedulers::current_thread</a> to allow mixing of underlying emissions</dd></dl>
<div class="image">
<object type="image/svg+xml" data="merge.svg" style="pointer-events: none;"></object>
</div>
<p>Actually it subscribes on each observable from emissions. Resulting observables completes when ALL observables completes</p>
<dl class="section user"><dt>Performance notes:</dt><dd><ul>
<li>2 heap allocation (1 for state, 1 to convert observer to <a class="el" href="classrpp_1_1dynamic__observer.html" title="Type-erased version of the rpp::observer. Any observer can be converted to dynamic_observer via rpp::...">dynamic_observer</a>)</li>
<li>Acquiring mutex during all observer's calls</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="merge_8hpp_source.html">rpp/operators/merge.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(<a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(1).as_dynamic(),</div>
<div class="line">                      <a class="code hl_function" href="group__creational__operators.html#ga16c57281cc1b24605ec23b09ec880416">rpp::source::never&lt;int&gt;</a>().as_dynamic(),</div>
<div class="line">                      <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(2).as_dynamic())</div>
<div class="line">        | <a class="code hl_function" href="#ga3f8a04b4c8eb945534eddde5a25eec74">rpp::operators::merge</a>()</div>
<div class="line">        | <a class="code hl_function" href="group__utility__operators.html#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 1 2</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/merge.html">https://reactivex.io/documentation/operators/merge.html</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="merge_8cpp-example.html#a2">merge.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga35392a84e52bf7101d0d0445ef391db7" name="ga35392a84e52bf7101d0d0445ef391db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35392a84e52bf7101d0d0445ef391db7">&#9670;&#160;</a></span>merge_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; <br />
requires constraint::observables_of_same_type&lt;std::decay_t&lt;TObservable&gt;, std::decay_t&lt;TObservables&gt;...&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::merge_with </td>
          <td>(</td>
          <td class="paramtype">TObservable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservables &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>observables</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines submissions from current observable with other observables into one. </p>
<dl class="section warning"><dt>Warning</dt><dd>According to observable contract (<a href="https://reactivex.io/documentation/contract.html">https://reactivex.io/documentation/contract.html</a>) emissions from any observable should be serialized, so, resulting observable uses mutex to satisfy this requirement</dd>
<dd>
During on subscribe operator takes ownership over <a class="el" href="classrpp_1_1schedulers_1_1current__thread.html" title="Schedules execution of schedulables via queueing tasks to the caller thread with priority to time_poi...">rpp::schedulers::current_thread</a> to allow mixing of underlying emissions</dd></dl>
<div class="image">
<object type="image/svg+xml" data="merge_with.svg" style="pointer-events: none;"></object>
</div>
<p>Actually it subscribes on each observable. Resulting observables completes when ALL observables completes</p>
<dl class="section user"><dt>Performance notes:</dt><dd><ul>
<li>2 heap allocation (1 for state, 1 to convert observer to <a class="el" href="classrpp_1_1dynamic__observer.html" title="Type-erased version of the rpp::observer. Any observer can be converted to dynamic_observer via rpp::...">dynamic_observer</a>)</li>
<li>Acquiring mutex during all observer's calls</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be merged with current observable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="merge_8hpp_source.html">rpp/operators/merge.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(1)</div>
<div class="line">        | <a class="code hl_function" href="#ga35392a84e52bf7101d0d0445ef391db7">rpp::operators::merge_with</a>(<a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(2))</div>
<div class="line">        | <a class="code hl_function" href="group__utility__operators.html#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 1 2</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/merge.html">https://reactivex.io/documentation/operators/merge.html</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="merge_8cpp-example.html#a4">merge.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gadf12c4de9702425819b0d34b5fdf7db3" name="gadf12c4de9702425819b0d34b5fdf7db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf12c4de9702425819b0d34b5fdf7db3">&#9670;&#160;</a></span>start_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; <br />
requires constraint::observables_of_same_type&lt;std::decay_t&lt;TObservable&gt;, std::decay_t&lt;TObservables&gt;...&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::start_with </td>
          <td>(</td>
          <td class="paramtype">TObservable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservables &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>observables</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines submissions from current observable with other observables into one but without overlapping and starting from observables provided as arguments. </p>
<dl class="section warning"><dt>Warning</dt><dd>If by some reason you need to interpet observables as "values", not sources of data, then use <code>start_with_values</code> instead</dd></dl>
<div class="image">
<object type="image/svg+xml" data="start_with_observable.svg" style="pointer-events: none;"></object>
</div>
<p>Actually it makes concat(observables_to_start_with..., current_observable) so observables from argument subscribed before current observable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observables</td><td>list of observables which should be used before current observable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="start__with_8hpp_source.html">rpp/operators/start_with.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"></div><!-- fragment --> <div class="fragment"></div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/startwith.html">https://reactivex.io/documentation/operators/startwith.html</a> </dd></dl>

</div>
</div>
<a id="ga04a8768b213581b77f025c39c42e1e78" name="ga04a8768b213581b77f025c39c42e1e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04a8768b213581b77f025c39c42e1e78">&#9670;&#160;</a></span>start_with_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::memory_model MemoryModel = memory_model::use_stack, <a class="el" href="conceptrpp_1_1schedulers_1_1constraint_1_1scheduler.html">rpp::schedulers::constraint::scheduler</a> TScheduler, typename T , typename... Ts&gt; <br />
requires (rpp::constraint::decayed_same_as&lt;T, Ts&gt; &amp;&amp; ...)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::start_with_values </td>
          <td>(</td>
          <td class="paramtype">const TScheduler &amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>vals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines submissions from current observable with values into one but without overlapping and starting from values provided as arguments. </p>
<div class="image">
<object type="image/svg+xml" data="start_with_values.svg" style="pointer-events: none;"></object>
</div>
<p>Actually it makes concat(rpp::source::just(vals_to_start_with)..., current_observable) so observables from argument subscribed before current observable</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memory_model</td><td>memory_model strategy used to store provided values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>list of values which should be emitted before current observable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="start__with_8hpp_source.html">rpp/operators/start_with.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"></div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/startwith.html">https://reactivex.io/documentation/operators/startwith.html</a> </dd></dl>

</div>
</div>
<a id="ga7bb4fbf5e43b500471881a900ef1d6b9" name="ga7bb4fbf5e43b500471881a900ef1d6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bb4fbf5e43b500471881a900ef1d6b9">&#9670;&#160;</a></span>start_with_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::memory_model MemoryModel = memory_model::use_stack, typename T , typename... Ts&gt; <br />
requires (rpp::constraint::decayed_same_as&lt;T, Ts&gt; &amp;&amp; ...)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::start_with_values </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>vals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines submissions from current observable with values into one but without overlapping and starting from values provided as arguments. </p>
<div class="image">
<object type="image/svg+xml" data="start_with_values.svg" style="pointer-events: none;"></object>
</div>
<p>Actually it makes concat(rpp::source::just(vals_to_start_with)..., current_observable) so observables from argument subscribed before current observable</p>
<p>This overloading operates on <a class="el" href="classrpp_1_1schedulers_1_1current__thread.html" title="Schedules execution of schedulables via queueing tasks to the caller thread with priority to time_poi...">rpp::schedulers::current_thread</a> by default</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memory_model</td><td>memory_model strategy used to store provided values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>list of values which should be emitted before current observable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="start__with_8hpp_source.html">rpp/operators/start_with.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"></div><!-- fragment --> <div class="fragment"></div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/startwith.html">https://reactivex.io/documentation/operators/startwith.html</a> </dd></dl>

</div>
</div>
<a id="ga917329dc13be7f4d037a12dcc1a1abe9" name="ga917329dc13be7f4d037a12dcc1a1abe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga917329dc13be7f4d037a12dcc1a1abe9">&#9670;&#160;</a></span>switch_on_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::switch_on_next </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts observable of observables into observable of values which emits values from most recent underlying observable till new observable obtained. </p>
<div class="image">
<object type="image/svg+xml" data="switch_on_next.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator just unsubscribes from previous observable and subscribes on new observable when obtained in <code>on_next</code></p>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="switch__on__next_8hpp_source.html">rpp/operators/switch_on_next.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(<a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(1).as_dynamic(),</div>
<div class="line">                      <a class="code hl_function" href="group__creational__operators.html#ga16c57281cc1b24605ec23b09ec880416">rpp::source::never&lt;int&gt;</a>().as_dynamic(),</div>
<div class="line">                      <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(2).as_dynamic())</div>
<div class="line">        | <a class="code hl_function" href="#ga917329dc13be7f4d037a12dcc1a1abe9">rpp::operators::switch_on_next</a>()</div>
<div class="line">        | <a class="code hl_function" href="group__utility__operators.html#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 1 2</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/switch.html">https://reactivex.io/documentation/operators/switch.html</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="switch_on_next_8cpp-example.html#a2">switch_on_next.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga20acc2f23cb06163f9d5e56c5522ce6c" name="ga20acc2f23cb06163f9d5e56c5522ce6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20acc2f23cb06163f9d5e56c5522ce6c">&#9670;&#160;</a></span>with_latest_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::with_latest_from </td>
          <td>(</td>
          <td class="paramtype">TObservable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservables &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>observables</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines latest emissions from observables with emission from current observable when it sends new value via making tuple. </p>
<div class="image">
<object type="image/svg+xml" data="with_latest_from.svg" style="pointer-events: none;"></object>
</div>
<dl class="section warning"><dt>Warning</dt><dd>Selector is just packing values to tuple in this case</dd></dl>
<dl class="section user"><dt>Performance notes:</dt><dd><ul>
<li>1 heap allocation for disposable</li>
<li>each value from "others" copied/moved to internal storage</li>
<li>mutex acquired every time value obtained</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be combined when current observable sends new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="with__latest__from_8hpp_source.html">rpp/operators/with_latest_from.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(1, 2, 3, 4, 5, 6)</div>
<div class="line">        | <a class="code hl_function" href="#ga9345ba5faac717ba85fc88f1c5fff58b">rpp::operators::with_latest_from</a>(<a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(3, 4, 5))</div>
<div class="line">        | <a class="code hl_function" href="group__utility__operators.html#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](std::tuple&lt;int, int&gt; v) { std::cout &lt;&lt; std::get&lt;0&gt;(v) &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::get&lt;1&gt;(v) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 1:3 2:4 3:5 4:5 5:5 6:5</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(1, 2, 3)</div>
<div class="line">        | <a class="code hl_function" href="#ga9345ba5faac717ba85fc88f1c5fff58b">rpp::operators::with_latest_from</a>(<a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(3, 4, 5, 6, 7, 8))</div>
<div class="line">        | <a class="code hl_function" href="group__utility__operators.html#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](std::tuple&lt;int, int&gt; v) { std::cout &lt;&lt; std::get&lt;0&gt;(v) &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::get&lt;1&gt;(v) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 1:3 2:4 3:5</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/combinelatest.html">https://reactivex.io/documentation/operators/combinelatest.html</a> </dd></dl>

</div>
</div>
<a id="ga9345ba5faac717ba85fc88f1c5fff58b" name="ga9345ba5faac717ba85fc88f1c5fff58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9345ba5faac717ba85fc88f1c5fff58b">&#9670;&#160;</a></span>with_latest_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector , <a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; <br />
requires (!<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a>&lt;TSelector&gt; &amp;&amp; (!utils::is_not_template_callable&lt;TSelector&gt; || std::invocable&lt;TSelector, rpp::utils::convertible_to_any, utils::extract_observable_type_t&lt;TObservable&gt;, utils::extract_observable_type_t&lt;TObservables&gt;...&gt;))</div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::with_latest_from </td>
          <td>(</td>
          <td class="paramtype">TSelector &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservables &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>observables</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines latest emissions from observables with emission from current observable when it sends new value via applying selector. </p>
<div class="image">
<object type="image/svg+xml" data="with_latest_from_custom_selector.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator just keeps last values from all other observables and combines them together with each new emission from original observable</p>
<dl class="section user"><dt>Performance notes:</dt><dd><ul>
<li>1 heap allocation for disposable</li>
<li>each value from "others" copied/moved to internal storage</li>
<li>mutex acquired every time value obtained</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>is applied to current emission of current observable and latests emissions from observables </td></tr>
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be combined when current observable sends new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="with__latest__from_8hpp_source.html">rpp/operators/with_latest_from.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line">    <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(1, 2, 3, 4)</div>
<div class="line">        | <a class="code hl_function" href="#ga9345ba5faac717ba85fc88f1c5fff58b">rpp::operators::with_latest_from</a>([](<span class="keywordtype">int</span> left, <span class="keywordtype">int</span> right) { <span class="keywordflow">return</span> left + right; },</div>
<div class="line">                                           <a class="code hl_function" href="group__creational__operators.html#ga1edf47f176050dd414e28a1c0616b7c0">rpp::source::just</a>(3, 4, 5))</div>
<div class="line">        | <a class="code hl_function" href="group__utility__operators.html#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 4 6 8 9</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/combinelatest.html">https://reactivex.io/documentation/operators/combinelatest.html</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="with_latest_from_8cpp-example.html#a1">with_latest_from.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga83f723fc5e197ab21f67b879c5a668d7" name="ga83f723fc5e197ab21f67b879c5a668d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f723fc5e197ab21f67b879c5a668d7">&#9670;&#160;</a></span>zip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::zip </td>
          <td>(</td>
          <td class="paramtype">TObservable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservables &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>observables</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>combines emissions from observables and emit tuple of items for each combination </p>
<div class="image">
<object type="image/svg+xml" data="zip.svg" style="pointer-events: none;"></object>
</div>
<dl class="section user"><dt>Performance notes:</dt><dd><ul>
<li>1 heap allocation for disposable</li>
<li>each value from any observable copied/moved to internal storage</li>
<li>mutex acquired every time value obtained</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be zipped with current observable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="zip_8hpp_source.html">rpp/operators/zip.hpp</a>&gt;</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/zip.html">https://reactivex.io/documentation/operators/zip.html</a> </dd></dl>

</div>
</div>
<a id="gae2e89ade7cae676333672b78db5f1a8b" name="gae2e89ade7cae676333672b78db5f1a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2e89ade7cae676333672b78db5f1a8b">&#9670;&#160;</a></span>zip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector , <a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a> TObservable, rpp::constraint::observable... TObservables&gt; <br />
requires (!<a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a>&lt;TSelector&gt; &amp;&amp; (!utils::is_not_template_callable&lt;TSelector&gt; || std::invocable&lt;TSelector, rpp::utils::convertible_to_any, utils::extract_observable_type_t&lt;TObservable&gt;, utils::extract_observable_type_t&lt;TObservables&gt;...&gt;))</div>
      <table class="memname">
        <tr>
          <td class="memname">auto rpp::operators::zip </td>
          <td>(</td>
          <td class="paramtype">TSelector &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservables &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>observables</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>combines emissions from observables and emit single items for each combination based on the results of provided selector </p>
<div class="image">
<object type="image/svg+xml" data="zip_custom_selector.svg" style="pointer-events: none;"></object>
</div>
<dl class="section user"><dt>Performance notes:</dt><dd><ul>
<li>1 heap allocation for disposable</li>
<li>each value from any observable copied/moved to internal storage</li>
<li>mutex acquired every time value obtained</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>is applied to current emission of current observable and latests emissions from observables </td></tr>
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be zipped with current observable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="zip_8hpp_source.html">rpp/operators/zip.hpp</a>&gt;</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/zip.html">https://reactivex.io/documentation/operators/zip.html</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>

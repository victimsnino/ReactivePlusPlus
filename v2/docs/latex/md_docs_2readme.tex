\chapter{Documentation}
\hypertarget{md_docs_2readme}{}\label{md_docs_2readme}\index{Documentation@{Documentation}}
\label{md_docs_2readme_autotoc_md0}%
\Hypertarget{md_docs_2readme_autotoc_md0}%
\hypertarget{md_docs_2readme_autotoc_md1}{}\doxysection{\texorpdfstring{Introduction to Reactive Programming}{Introduction to Reactive Programming}}\label{md_docs_2readme_autotoc_md1}
\begin{DoxyImportant}{Important}
I\textquotesingle{}m highly recommend to read this article beforehand\+: \href{https://gist.github.com/staltz/868e7e9bc2a7b8c1f754}{\texttt{ The introduction to Reactive Programming you\textquotesingle{}ve been missing}}
\end{DoxyImportant}
\hypertarget{md_docs_2readme_autotoc_md2}{}\doxysubsection{\texorpdfstring{What is Reactive Programming?}{What is Reactive Programming?}}\label{md_docs_2readme_autotoc_md2}
{\bfseries{Reactive programming}} is a {\itshape design paradigm} that focuses on building applications that can efficiently respond to asynchronous {\bfseries{events}}.

Actually, any application or function has two core parts\+: input and output. Input/output can even be empty\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}


Input/output itself can be split into the following two types\+:


\begin{DoxyItemize}
\item {\bfseries{Static}} -\/ Your application or function just accepts such an input and handles it somehow. For example, arguments from the command line or arguments of your function\+:
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ sum(\textcolor{keywordtype}{int}\ a,\ \textcolor{keywordtype}{int}\ b)\ \{\ \textcolor{keywordflow}{return}\ a\ +\ b;\ \}}

\end{DoxyCode}



\begin{DoxyItemize}
\item {\bfseries{Distributed in time}} -\/ Your application or function doesn\textquotesingle{}t know exact length of input, {\bfseries{when}} input (or any parts of it) would arrive, but knows {\bfseries{what}} to do when it happens\+:
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \textcolor{keywordflow}{while}(\textcolor{keyword}{true})}
\DoxyCodeLine{\ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{keyword}{auto}\ ch\ =\ ::getchar();}
\DoxyCodeLine{\ \ \ \ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}Obtained\ char\ "{}}\ <<\ ch\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


When dealing with input that is {\bfseries{distributed in time}}, there are two ways to handle it\+:


\begin{DoxyItemize}
\item {\bfseries{Pulling}} -\/ You decide {\bfseries{when}} you need extra data (e.\+g., to get something, request, iterate, etc.) and you are simply {\bfseries{checking/requesting}} some data. In most cases, this is a blocking operation of requesting data and waitign to be available or periodically checking its current status. For example, if you like a blog with non-\/periodical posts, you may check it daily for new posts manually.
\item {\bfseries{Pushing}} -\/ You decide {\bfseries{once}} that you are interested in a source of data, notify this source somehow (e.\+g., register, subscribe, etc.), and {\bfseries{react}} when new data {\bfseries{becomes available}} to you. For example, you might {\bfseries{subscribe}} to a blog and {\bfseries{react}} to new posts only after receiving a notification on your smartphone, rather than manually checking for updates.
\end{DoxyItemize}

Reactive programming is a powerful way to handle input that is {\bfseries{distributed in time}}. Instead of constantly polling for updates or waiting for input to arrive, reactive programming allows you to {\bfseries{register}} callbacks to be executed {\bfseries{when the input becomes available}}.

See \href{https://reactivex.io/intro.html}{\texttt{ https\+://reactivex.\+io/intro.\+html}} for more details.\hypertarget{md_docs_2readme_autotoc_md3}{}\doxysubsection{\texorpdfstring{Core concepts of Reactive Programming}{Core concepts of Reactive Programming}}\label{md_docs_2readme_autotoc_md3}
In short, Reactive Programming can be described as follows\+:


\begin{DoxyItemize}
\item An {\bfseries{Observer}} subscribes to an {\bfseries{Observable}}.
\item The {\bfseries{Observable}} automatically notifies its subscribed {\bfseries{Observers}} about any new events/emissions. {\bfseries{Observable}} could invoke next {\bfseries{observer}}\textquotesingle{}s method\+:
\begin{DoxyItemize}
\item {\bfseries{on\+\_\+next(\+T)}} -\/ notifies about new event/emission
\item {\bfseries{on\+\_\+error(std\+::exception\+\_\+ptr)}} -\/ notified about error during work. It is termination event (no more calls from this observable should be expected)
\item {\bfseries{on\+\_\+completed()}} -\/ notified about successful completion.\+It is termination event (no more calls from this observable should be expected)
\item {\bfseries{set\+\_\+upstream(disposable)}} -\/ observable could pass to observer it\textquotesingle{}s own disposable to provide ability for observer to terminate observable\textquotesingle{}s internal actions/state.
\item {\bfseries{is\+\_\+disposed()}} -\/ observable could check if observer is still interested in this source data (==false) or disposed and not listening anymore (==true)
\end{DoxyItemize}
\item During subscription, the {\bfseries{Observable}} can return/provide a {\bfseries{Disposable}} for {\bfseries{Observer}} to provide ability to check if observable is still alive or make early termination (==dispose) if needed.
\end{DoxyItemize}

For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <rpp/rpp.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{group__creational__operators_gae68c87e7ae3a505258b733082bf68513}{rpp::source::create<int>}}([](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ observer)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (!observer.is\_disposed())}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{char}\ ch\ =\ ::getchar();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!::isdigit(ch))}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ observer.on\_error(std::make\_exception\_ptr(std::runtime\_error\{\textcolor{stringliteral}{"{}Invalid\ symbol"{}}\}));}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ digit\ =\ ch\ -\/\ \textcolor{charliteral}{'0'};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (digit\ ==\ 0)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ observer.on\_completed();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ observer.on\_next(digit);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \})}
\DoxyCodeLine{\ \ \ \ .\mbox{\hyperlink{group__utility__operators_ga149309d4b2e0f1201f1ab42597ace8ac}{subscribe}}([](\textcolor{keywordtype}{int}\ val)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}obtained\ val\ "{}}\ <<\ val\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [](std::exception\_ptr\ err)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}obtained\ error\ "{}}\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ []()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}Completed"{}}\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ input:\ 123456d}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ output:\ \ obtained\ val\ 1}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ obtained\ val\ 2}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ obtained\ val\ 3}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ obtained\ val\ 4}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ obtained\ val\ 5}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ obtained\ val\ 6}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ obtained\ error}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ input:\ 1230}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ output:\ obtained\ val\ 1}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ obtained\ val\ 2}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ obtained\ val\ 3}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ Completed}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}


There we are creating observable that emits digits from console input\+:In case of user promted something else it is {\bfseries{error}} for our observable (it is expected to emit ONLY digits). In this case we are notifying observer about it and just stopping. When user prompts {\ttfamily 0}, it means "{}end of observable"{}.

See \href{https://reactivex.io/documentation/observable.html}{\texttt{ https\+://reactivex.\+io/documentation/observable.\+html}} for more details.

In such an way it is not powerful enough, so Reactive Programming provides a list of {\bfseries{operators}}.\hypertarget{md_docs_2readme_autotoc_md4}{}\doxysubsection{\texorpdfstring{Observable contract}{Observable contract}}\label{md_docs_2readme_autotoc_md4}
Reactive programming has \href{https://reactivex.io/documentation/contract.html}{\texttt{ Observable Contract}}. Please, read it.

This contact has next important part\+:

\begin{quote}
Observables must issue notifications to observers serially (not in parallel). They may issue these notifications from different threads, but there must be a formal happens-\/before relationship between the notifications \end{quote}
RPP follows this contract and especially this part. It means, that\+:


\begin{DoxyEnumerate}
\item {\bfseries{All}} implemented in {\bfseries{RPP operators}} are {\bfseries{following this contract}}\+:~\newline
 All built-\/in RPP observables/operators emit emissions serially
\item Any user-\/provided callbacks (for operators or observers) can be not thread-\/safe due to thread-\/safety of observable is guaranteed. ~\newline
 For example\+: internal logic of {\ttfamily take} operator doesn\textquotesingle{}t use mutexes or atomics due to underlying observable {\bfseries{MUST}} emit items serially
\item When you implement your own operator via {\ttfamily create} be careful to {\bfseries{follow this contract}}!
\item It is true {\bfseries{EXCEPT FOR}} subjects if they are used manually due to users can use subjects for its own purposes there is potentially place for breaking this concept. Be careful and use serialized\+\_\+\texorpdfstring{$\ast$}{*} instead if can\textquotesingle{}t guarantee serial emissions!
\end{DoxyEnumerate}

It means, that for example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ s1\ =\ \mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(1)\ |\ \mbox{\hyperlink{group__utility__operators_ga41ef49dc75a3eadb0eb3fda7c3692c40}{rpp::operators::repeat}}()\ |\ \mbox{\hyperlink{group__utility__operators_gace728cfbf71720901cb6f310edabf8b0}{rpp::operators::subscribe\_on}}(\mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ s2\ =\ \mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(2)\ |\ \mbox{\hyperlink{group__utility__operators_ga41ef49dc75a3eadb0eb3fda7c3692c40}{rpp::operators::repeat}}()\ |\ \mbox{\hyperlink{group__utility__operators_gace728cfbf71720901cb6f310edabf8b0}{rpp::operators::subscribe\_on}}(\mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\});}
\DoxyCodeLine{s1\ |\ \mbox{\hyperlink{group__combining__operators_ga35392a84e52bf7101d0d0445ef391db7}{rpp::operators::merge\_with}}(s2)}
\DoxyCodeLine{\ \ \ |\ \mbox{\hyperlink{group__transforming__operators_ga1291dba2d973d4ba1061c9e0e202cb3f}{rpp::operators::map}}([](\textcolor{keywordtype}{int}\ v)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}enter\ "{}}\ <<\ v\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ std::this\_thread::sleep\_for(std::chrono::seconds\{1\});}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}exit\ "{}}\ <<\ v\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ v;}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\ \ |\ \mbox{\hyperlink{group__utility__operators_ga9df008c11eeff8c9383e56bf36e28ec2}{rpp::operators::as\_blocking}}()}
\DoxyCodeLine{\ \ |\ \mbox{\hyperlink{group__utility__operators_ga149309d4b2e0f1201f1ab42597ace8ac}{rpp::operators::subscribe}}([](\textcolor{keywordtype}{int})\{\});}

\end{DoxyCode}


will never produce something like


\begin{DoxyCode}{0}
\DoxyCodeLine{enter\ 1}
\DoxyCodeLine{enter\ 2}
\DoxyCodeLine{exit\ 2}
\DoxyCodeLine{exit\ 1}

\end{DoxyCode}


only serially


\begin{DoxyCode}{0}
\DoxyCodeLine{enter\ 1}
\DoxyCodeLine{exit\ 1}
\DoxyCodeLine{enter\ 1}
\DoxyCodeLine{exit\ 1}
\DoxyCodeLine{enter\ 2}
\DoxyCodeLine{exit\ 2}
\DoxyCodeLine{enter\ 2}
\DoxyCodeLine{exit\ 2}

\end{DoxyCode}
\hypertarget{md_docs_2readme_autotoc_md5}{}\doxysubsection{\texorpdfstring{Operators}{Operators}}\label{md_docs_2readme_autotoc_md5}
{\bfseries{Operators}} are way to modify the {\bfseries{Observable}}\textquotesingle{}s emissions to adapt values to the {\bfseries{Observer}}.

For example, we can create observable to get chars from console input, do it till ‘0’ char, get only letters and send to observer this letters as UPPER. With operators it is pretty simple to do it in correct way\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <rpp/rpp.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{group__creational__operators_ga519523490394660d7e8c46d2d5612f75}{rpp::source::from\_callable}}(\&::getchar)}
\DoxyCodeLine{\ \ \ \ |\ \mbox{\hyperlink{group__utility__operators_ga41ef49dc75a3eadb0eb3fda7c3692c40}{rpp::operators::repeat}}()}
\DoxyCodeLine{\ \ \ \ |\ \mbox{\hyperlink{group__conditional__operators_gac65952f7460d8f0e71a93d95810d2061}{rpp::operators::take\_while}}([](\textcolor{keywordtype}{char}\ v)\ \{\ \textcolor{keywordflow}{return}\ v\ !=\ \textcolor{charliteral}{'0'};\ \})}
\DoxyCodeLine{\ \ \ \ |\ \mbox{\hyperlink{group__filtering__operators_ga3ad579153e7975af6ae4b75f585fb873}{rpp::operators::filter}}(std::not\_fn(\&::isdigit))}
\DoxyCodeLine{\ \ \ \ |\ \mbox{\hyperlink{group__transforming__operators_ga1291dba2d973d4ba1061c9e0e202cb3f}{rpp::operators::map}}(\&::toupper)}
\DoxyCodeLine{\ \ \ \ |\ \mbox{\hyperlink{group__utility__operators_ga149309d4b2e0f1201f1ab42597ace8ac}{rpp::operators::subscribe}}([](\textcolor{keywordtype}{char}\ v)\ \{\ std::cout\ <<\ v;\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ input:\ 12345qwer5125ttqt0}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ output:\ QWERTTQT}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}


You can check documentation for each operator on \href{https://victimsnino.github.io/ReactivePlusPlus/v2/docs/html/group__rpp.html}{\texttt{ API Reference}} page. Below you can find details about how operator works and how to create your own custom operator in RPP.

See \href{https://reactivex.io/documentation/operators.html}{\texttt{ https\+://reactivex.\+io/documentation/operators.\+html}} for more details about operators concept.\hypertarget{md_docs_2readme_autotoc_md6}{}\doxysubsubsection{\texorpdfstring{How operator works?}{How operator works?}}\label{md_docs_2readme_autotoc_md6}
Let\textquotesingle{}s check this example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_gae68c87e7ae3a505258b733082bf68513}{rpp::source::create<int>}}([](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ observer)\{}
\DoxyCodeLine{\ \ observer.on\_next(1);}
\DoxyCodeLine{\ \ observer.on\_completed();}
\DoxyCodeLine{\});}

\end{DoxyCode}


This example shows next\+: we create observble of {\ttfamily int} via operator {\ttfamily create}. This observable just emits to observer value {\ttfamily 1} and then completes. Type of this observable is {\ttfamily \doxylink{classrpp_1_1observable}{rpp\+::observable}\texorpdfstring{$<$}{<}int, ...\texorpdfstring{$>$}{>}} where {\ttfamily ...} implementation defined type. So, actually it is {\ttfamily observable of ints}. Let\textquotesingle{}s say we want to convert {\ttfamily int} to {\ttfamily std\+::string}. We could subscribe and then convert it or use {\ttfamily map} operator (also known as {\ttfamily transform}) to transform some original value to some another value\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_gae68c87e7ae3a505258b733082bf68513}{rpp::source::create<int>}}([](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ observer)\{}
\DoxyCodeLine{\ \ observer.on\_next(1);}
\DoxyCodeLine{\ \ observer.on\_completed();}
\DoxyCodeLine{\})}
\DoxyCodeLine{|\ \mbox{\hyperlink{group__transforming__operators_ga1291dba2d973d4ba1061c9e0e202cb3f}{rpp::operators::map}}([](\textcolor{keywordtype}{int}\ v)\{\ \textcolor{keywordflow}{return}\ std::string\{v\};\ \});}

\end{DoxyCode}


For now it is {\ttfamily observable of strings} due to it is {\ttfamily \doxylink{classrpp_1_1observable}{rpp\+::observable}\texorpdfstring{$<$}{<}std\+::string, ...\texorpdfstring{$>$}{>}}. But what is {\ttfamily \doxylink{group__transforming__operators_ga1291dba2d973d4ba1061c9e0e202cb3f}{rpp\+::operators\+::map}} then? Actually it is functor-\/adaptor -\/ just functor accepting observable and returning another observable. It accepts original observable and converts it to observable of "{}final type"{}. "{}final type"{} is result of invocation of passed function against original observable\textquotesingle{}s type. In our case it is {\ttfamily decltype(\mbox{[}\mbox{]}(int v)\{ return std\+::string\{v\}; \}(int\{\}))} is it is {\ttfamily std\+::string}. So, {\ttfamily map} can be implemented in the following way\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Fn>}
\DoxyCodeLine{\textcolor{keyword}{struct\ }\mbox{\hyperlink{group__transforming__operators_ga1291dba2d973d4ba1061c9e0e202cb3f}{map}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ Fn\ fn\{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Type,\ \textcolor{keyword}{typename}\ Internal>}
\DoxyCodeLine{\ \ \textcolor{keyword}{auto}\ operator()(\textcolor{keyword}{const}\ \mbox{\hyperlink{classrpp_1_1observable}{rpp::observable<Type,\ Internal>}}\&\ observable)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{using\ }FinalType\ =\ std::invoke\_result\_t<Fn,\ Type>;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{group__creational__operators_gae68c87e7ae3a505258b733082bf68513}{rpp::source::create<FinalType>}}([observable,\ fn](\textcolor{keyword}{const}\ \mbox{\hyperlink{classrpp_1_1dynamic__observer}{rpp::dynamic\_observer<FinalType>}}\&\ observer)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ observable.\mbox{\hyperlink{classrpp_1_1observable_a193b0e08c516912c04afd8379ec27182}{subscribe}}([observer,\ fn](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ v)\ \{\ observer.\mbox{\hyperlink{classrpp_1_1details_1_1observer__impl_a14747a5260ecc183a6d0f1adafee4f68}{on\_next}}(fn(v));\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [observer](\textcolor{keyword}{const}\ std::exception\_ptr\&\ err)\ \{\ observer.\mbox{\hyperlink{classrpp_1_1details_1_1observer__impl_aa55c5a334bc39c92218f7b51e5126bbc}{on\_error}}(err);\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [observer]()\ \{\ observer.\mbox{\hyperlink{classrpp_1_1details_1_1observer__impl_a7a73f13eae52effde01a2d3b2cf1d1b4}{on\_completed}}();\ \});}
\DoxyCodeLine{\ \ \ \ \};);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


It is template for such an functor-\/adaptor. Provided example -\/ is simplest possible way to implement new operators -\/ just provide function for transformation of observable. For example, it is fully valid example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(1)}
\DoxyCodeLine{\ \ \ \ |\ [](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ observable)\ \{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{group__creational__operators_gab6cfd9da2e3590fd199c9972477e04df}{rpp::source::concat}}(observable,\ \mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(2));\ \};}

\end{DoxyCode}


There we convert observable to concatenation of original observable and {\ttfamily just(2)}.

One more posible but a bit more advanced way to implement operators -\/ is to lift observer. To do this, your functor-\/adapter must to satisfy {\ttfamily \doxylink{conceptrpp_1_1constraint_1_1operator__lift}{rpp\+::constraint\+::operator\+\_\+lift}} concept. Actually, your class must to have\+:
\begin{DoxyItemize}
\item member function {\ttfamily lift} accepting downstream observer and returning new upstream observer
\item inner {\ttfamily template\texorpdfstring{$<$}{<}rpp\+::constraint\+::decayed\+\_\+type T\texorpdfstring{$>$}{>} struct traits} struct accepting typename of upstream and providing\+:
\begin{DoxyItemize}
\item {\ttfamily using result\+\_\+type =} with typename of new resulting type for new observable
\item (optionally) {\ttfamily struct requirements} with static\+\_\+asserts over passed type
\end{DoxyItemize}
\end{DoxyItemize}

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Fn>}
\DoxyCodeLine{\textcolor{keyword}{struct\ }\mbox{\hyperlink{group__transforming__operators_ga1291dba2d973d4ba1061c9e0e202cb3f}{map}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}<rpp::constra\textcolor{keywordtype}{int}::decayed\_type\ T>}
\DoxyCodeLine{\ \ \textcolor{keyword}{struct\ }traits}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{struct\ }requirements}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{static\_assert}(std::invocable<Fn,\ T>,\ \textcolor{stringliteral}{"{}Fn\ is\ not\ invocable\ with\ T"{}});}
\DoxyCodeLine{\ \ \ \ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{using\ }result\_type\ =\ std::invoke\_result\_t<Fn,\ T>;}
\DoxyCodeLine{\ \ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ Fn\ fn\{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Upstream,\ \textcolor{keyword}{typename}\ Downstream>}
\DoxyCodeLine{\ \ \textcolor{keyword}{auto}\ lift(\textcolor{keyword}{const}\ \mbox{\hyperlink{classrpp_1_1dynamic__observer}{rpp::dynamic\_observer<Downstream>}}\&\ observer)\textcolor{keyword}{\ const}}
\DoxyCodeLine{\textcolor{keyword}{\ \ }\{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{group__observers_gae17f62f64102925f4cd2eb29c4c27028}{rpp::make\_lambda\_observer<Upstream>}}([observer,\ fn](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ v)\{\ observer.\mbox{\hyperlink{classrpp_1_1details_1_1observer__impl_a14747a5260ecc183a6d0f1adafee4f68}{on\_next}}(fn(v));\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [observer](\textcolor{keyword}{const}\ std::exception\_ptr\&\ err)\ \{\ observer.\mbox{\hyperlink{classrpp_1_1details_1_1observer__impl_aa55c5a334bc39c92218f7b51e5126bbc}{on\_error}}(err);\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [observer]()\ \{\ observer.\mbox{\hyperlink{classrpp_1_1details_1_1observer__impl_a7a73f13eae52effde01a2d3b2cf1d1b4}{on\_completed}}();\ \});}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 In this case you providing logic how to convert downstream observer to upstream observer. Actually this implementation is equal to previous one, but without handling of observable -\/ you are expressing your operator in terms of observers

{\bfseries{(Advanced)}} In case of implementing operator via {\ttfamily lift} you can control disposable strategy via {\ttfamily updated\+\_\+disposable\+\_\+strategy} parameter. It accepts disposable strategy of upstream and returns disposable strategy for downstream. It needed only for optimization and reducing disposables handling cost and it is purely advanced thing. Not sure if anyone is going to use it by its own for now =)\hypertarget{md_docs_2readme_autotoc_md7}{}\doxysubsection{\texorpdfstring{Schedulers}{Schedulers}}\label{md_docs_2readme_autotoc_md7}
Reactive programming becomes even more powerful when observables can operate across multiple threads, rather than being confined to the thread of creation and subscription. This allows for non-\/blocking, asynchronous operations and provides significant advantages over raw iteration or other pull-\/based approaches. To enable multithreading in your observables, you can use {\bfseries{Schedulers}}.

By default, an {\bfseries{Observable}} will perform its work in the thread where the {\bfseries{subscribe}} operation occurs. However, you can change this behavior using the {\bfseries{subscribe\+\_\+on}} operator. This operator forces the observable to perform the {\bfseries{subscription}} and any subsequent work in the specified {\bfseries{scheduler}}. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(1,2,3,4,5)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ 1}}
\DoxyCodeLine{|\ \mbox{\hyperlink{group__utility__operators_gace728cfbf71720901cb6f310edabf8b0}{rpp::operators::subscribe\_on}}(\mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\})\ \textcolor{comment}{//\ 2}}
\DoxyCodeLine{|\ \mbox{\hyperlink{group__utility__operators_ga149309d4b2e0f1201f1ab42597ace8ac}{rpp::operators::subscribe}}([](\textcolor{keyword}{auto})\{\});\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ 3}}

\end{DoxyCode}


In this case subscribe to {\ttfamily 3} happens in current thread (where subscribe invoked). But during subscription to {\ttfamily 2} it schedules subscription to {\ttfamily 1} to provided {\ttfamily new\+\_\+thread} scheduler. So, subscription to final observable and it\textquotesingle{}s internal logic (iterating and emitting of values) happens inside new\+\_\+thread. Actually it is something like this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_gae68c87e7ae3a505258b733082bf68513}{rpp::source::create<int>}}([](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ observer)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\}.create\_worker([](...)\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(1,2,3,4,5).subscribe(observer);}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\}).\mbox{\hyperlink{group__utility__operators_ga149309d4b2e0f1201f1ab42597ace8ac}{subscribe}}(...);}

\end{DoxyCode}


The {\bfseries{observe\+\_\+on}} operator specifies the {\bfseries{scheduler}} that will be used for emission during the processing of further operators after {\bfseries{observe\+\_\+on}}. For example


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(1,2,3,4,5)}
\DoxyCodeLine{|\ \mbox{\hyperlink{group__utility__operators_ga3feb1b1258c7e3e72c151abf176c30c4}{rpp::operators::observe\_on}}(\mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\})}
\DoxyCodeLine{|\ \mbox{\hyperlink{group__utility__operators_ga149309d4b2e0f1201f1ab42597ace8ac}{rpp::operators::subscribe}}([](\textcolor{keyword}{auto})\{\});}

\end{DoxyCode}


In this case whole subscription flow happens in thread of subscription, but emission of values transfers to another thread. Actually it is something like this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_gae68c87e7ae3a505258b733082bf68513}{rpp::source::create<int>}}([](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ observer)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keyword}{auto}\ worker\ =\ \mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\}.create\_worker();}
\DoxyCodeLine{\ \ \mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(1,2,3,4,5).subscribe([](\textcolor{keywordtype}{int}\ v)\ \{}
\DoxyCodeLine{\ \ \ \ worker.scheduler([](...)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ observer.\mbox{\hyperlink{classrpp_1_1details_1_1observer__impl_a14747a5260ecc183a6d0f1adafee4f68}{on\_next}}(v);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\}).\mbox{\hyperlink{group__utility__operators_ga149309d4b2e0f1201f1ab42597ace8ac}{subscribe}}(...);}

\end{DoxyCode}


A {\bfseries{Scheduler}} is responsible for controlling the type of multithreading behavior (or lack thereof) used in the observable. For example, a {\bfseries{scheduler}} can utilize a new thread, a thread pool, or a raw queue to manage its processing.

Checkout \href{https://victimsnino.github.io/ReactivePlusPlus/v2/docs/html/group__rpp.html}{\texttt{ API Reference}} to learn more about schedulers in RPP.

See \href{https://reactivex.io/documentation/scheduler.html}{\texttt{ https\+://reactivex.\+io/documentation/scheduler.\+html}} for more details about scheduler concept.\hypertarget{md_docs_2readme_autotoc_md8}{}\doxysubsection{\texorpdfstring{Disposable}{Disposable}}\label{md_docs_2readme_autotoc_md8}
In reactive programming, a {\bfseries{disposable}} is an object that represents a resource that needs to be released or disposed of when it is no longer needed. This can include things like file handles, network connections, or any other resource that needs to be cleaned up after use.

The purpose of a disposable is to provide a way to manage resources in a safe and efficient manner. By using disposables, you can ensure that resources are released in a timely manner, preventing memory leaks and other issues that can arise from resource leaks.

In most cases disposables are placed in observers. RPP\textquotesingle{}s observer can use two types of disposables\+:


\begin{DoxyEnumerate}
\item {\bfseries{Upstream disposable}} -\/ This is a disposable that the observable puts into the observer. The upstream disposable keeps some state or callback that should be disposed of when the observer is disposed. This ensures that any resources used by the observable are properly cleaned up when the observer obtains on\+\_\+error/on\+\_\+completed or disposed in any other way.
\item {\bfseries{External disposable}} -\/ This is a disposable that allows the observer to be disposed of from outside the observer itself. This can be useful in situations where you need to cancel an ongoing operation or release resources before the observable has completed its work.
\end{DoxyEnumerate}\hypertarget{md_docs_2readme_autotoc_md9}{}\doxysubsection{\texorpdfstring{Exception guarantee}{Exception guarantee}}\label{md_docs_2readme_autotoc_md9}
In non-\/reactive programming functions/modules throws exception in case of something invalid. As a result, user can catch it and handle it somehow while internal state of objects can be in some state (invalid/untouched/partly valid) and etc.

In reactive programming there is another way of exception mechanism\+: throwing exception as is from original place is useless. Notification about "{}something goes wrong"{} need to receive observer/subscriber, not owner of callstack. As a result, ANY exception obtained during emitting items and etc WOULD be delivered to subscriber/observer via {\ttfamily on\+\_\+error} function and then unsubscribe happens. As a result, no any raw exceptions would be throws during using RPP. In case of emitting {\ttfamily on\+\_\+error} whole internal state of observable keeps valid but it doesn\textquotesingle{}t matter -\/ whole chain would be destroyed due to {\ttfamily on\+\_\+error} forces unsubscribe. Reactive catching mechanisms like {\ttfamily catch} or {\ttfamily retry} {\bfseries{re-\/subscribes}} on observable. it means, that new chain with new states would be created, not re-\/used existing one.\hypertarget{md_docs_2readme_autotoc_md10}{}\doxysubsection{\texorpdfstring{Memory Model}{Memory Model}}\label{md_docs_2readme_autotoc_md10}
In Reactive\+Plus\+Plus there is new concept unique for this implementation\+: rpp\+::memory\+\_\+model\+:

Some of the operators and sources like {\ttfamily \doxylink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp\+::source\+::just}} or {\ttfamily \doxylink{group__combining__operators_gadf12c4de9702425819b0d34b5fdf7db3}{rpp\+::operators\+::start\+\_\+with}} accepts user\textquotesingle{}s variables for usage. Some of this types can be such an expensive to copy or move and it would be preferable to copy it once to heap, but some other types (like POD) are cheap enough and usage of heap would be overkill. But these variables should be saved inside somehow!

So, RPP provides ability to select strategy "{}how to deal with such a variables"{} via {\ttfamily rpp\+::memory\+\_\+model} enum.\hypertarget{md_docs_2readme_autotoc_md11}{}\doxysubsubsection{\texorpdfstring{Examples}{Examples}}\label{md_docs_2readme_autotoc_md11}
For example, {\ttfamily \doxylink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp\+::source\+::just}}


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(my\_custom\_variable);}

\end{DoxyCode}
 by default {\ttfamily just} uses {\ttfamily \doxylink{structrpp_1_1memory__model_1_1use__stack}{rpp\+::memory\+\_\+model\+::use\+\_\+stack}} and {\ttfamily my\+\_\+custom\+\_\+variable} would be copied and moved everywhere when needed. On the other hand


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just<rpp::memory\_model::use\_shared>}}(my\_custom\_variable);}

\end{DoxyCode}
 makes only 1 copy/move to shared\+\_\+ptr and then uses it instead.

As a a result, users can select preferable way of handling of their types.\hypertarget{md_docs_2readme_autotoc_md12}{}\doxysection{\texorpdfstring{Reactive\+Plus\+Plus details}{Reactive\+Plus\+Plus details}}\label{md_docs_2readme_autotoc_md12}
\hypertarget{md_docs_2readme_autotoc_md13}{}\doxysubsection{\texorpdfstring{Disposable}{Disposable}}\label{md_docs_2readme_autotoc_md13}
Rpp has following disposables related classes\+:
\begin{DoxyItemize}
\item {\ttfamily interface\+\_\+disposable} -\/ is base inerface for all disposables in RPP. Simplest ever disposable with {\ttfamily dispose()} and {\ttfamily is\+\_\+disposed()} method. This type of disposable observable is passing to observer.
\begin{DoxyItemize}
\item {\ttfamily callback\+\_\+disposable} -\/ is just {\bfseries{noexcept}} to be called on dispose. Can be constructed like this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ d\ =\ rpp::make\_callback\_disposable([]()\ \textcolor{keyword}{noexcept}\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}DISPOSED!\ "{}}\ <<\ std::endl;\ \});}

\end{DoxyCode}

\end{DoxyItemize}
\item {\ttfamily interface\+\_\+composite\+\_\+disposable} -\/ is base interface for disposables able to keep dependent disposables inside\+: main difference -\/ new method {\ttfamily add} accepting another dispoable inhereting from {\ttfamily interface\+\_\+disposable}. Main idea\+: {\ttfamily interface\+\_\+composite\+\_\+disposable} is aggregating other disposables inside and during {\ttfamily dispose()} method calling {\ttfamily dispose()} method of its dependents.
\begin{DoxyItemize}
\item {\ttfamily composite\+\_\+disposable} -\/ is concrete realization of {\ttfamily interface\+\_\+composite\+\_\+disposable}
\item {\ttfamily refcount\+\_\+disposable} -\/ is variant of {\ttfamily composite\+\_\+disposable} but it keeps refcounter inside. This counter can be incremented with help of {\ttfamily add\+\_\+ref()} method returning new dependent {\ttfamily composite\+\_\+disposable}. Idea is simple\+: original {\ttfamily refcount\+\_\+disposable} would be disposed IF all of its dependents disposables (created via {\ttfamily add\+\_\+ref()} ) {\ttfamily dispose()} methods were called.
\end{DoxyItemize}
\end{DoxyItemize}

All disposable in RPP should be created and used via {\ttfamily \doxylink{classrpp_1_1disposable__wrapper__impl}{rpp\+::disposable\+\_\+wrapper\+\_\+impl}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} wrapper. For simplicity usage it has 2 base aliases\+:
\begin{DoxyItemize}
\item {\ttfamily disposable\+\_\+wrapper} -\/ wrapper over {\ttfamily interface\+\_\+disposable}
\item {\ttfamily composite\+\_\+disposable\+\_\+wrapper} -\/ wrapper over {\ttfamily interface\+\_\+composite\+\_\+disposable}
\end{DoxyItemize}

{\ttfamily disposable\+\_\+wrapper} is kind of smart\+\_\+pointer (like std\+::unique\+\_\+ptr) but for disposables. So, default constructed wrapper is empty wrapper. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ d\ =\ \mbox{\hyperlink{classrpp_1_1disposable__wrapper__impl}{rpp::disposable\_wrapper}}\{\};}

\end{DoxyCode}
 Comparing to unique\+\_\+ptr wrapper\textquotesingle{}s methods are safe to use for empty wrapper. To construct wrapper you have to use {\ttfamily make} method\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ d\ =\ \mbox{\hyperlink{classrpp_1_1disposable__wrapper__impl_a677053a7d4cc81ab26dc7f740a6595e6}{rpp::disposable\_wrapper::make<SomeSpecificDisposableType>}}(some\_arguments,\ to\_construct\_it);}

\end{DoxyCode}


Wrapper has popluar methods to work with disposable\+: {\ttfamily dispose()}, {\ttfamily is\+\_\+disposed()} and {\ttfamily add()}/{\ttfamily remove()}/{\ttfamily clear()} (for {\ttfamily interface\+\_\+composite\+\_\+disposable}).

In case of you want to obtain original disposable, you can use {\ttfamily lock()} method returning shared\+\_\+ptr.

{\ttfamily disposable\+\_\+wrapper} can be strong and weak\+:
\begin{DoxyItemize}
\item strong (it is default behavior) is keeping disposable as shared\+\_\+ptr, so, such an instance of wrapper is extending life-\/time is underlying disposable
\item weak (disposable\+\_\+wrapper can be forced to weak via {\ttfamily as\+\_\+weak()} method) is keeping disposable as weak\+\_\+ptr, so, such an instance of wrapper is {\bfseries{NOT}} extendning life-\/time is underlying disposable
\end{DoxyItemize}

This wrapper is needed for 2 goals\+:
\begin{DoxyItemize}
\item provide safe usage of disposables avoiding manual handling of empty/weak disposables
\item automatically call {\ttfamily dispose()} during destruction of any disposable
\end{DoxyItemize}

To achieve desired performance RPP is avoiding to returning disposable by default. So, it is why {\ttfamily subscribe} method is not returning anything by default. If you want to attach disposable to observer you can use overloading method accepting disposable as first argument like this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ d\ =\ \mbox{\hyperlink{classrpp_1_1disposable__wrapper__impl_a677053a7d4cc81ab26dc7f740a6595e6}{rpp::composite\_disposable\_wrapper::make}}();}
\DoxyCodeLine{observable.\mbox{\hyperlink{classrpp_1_1observable_a193b0e08c516912c04afd8379ec27182}{subscribe}}(d,\ [](\textcolor{keywordtype}{int}\ v)\{\});}

\end{DoxyCode}
 or use {\ttfamily subscribe\+\_\+with\+\_\+disposable} method instead 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ d\ =\ observable.\mbox{\hyperlink{classrpp_1_1observable_ac81ee3d805386d492ab54e40ccd6adc2}{subscribe\_with\_disposable}}([](\textcolor{keywordtype}{int})\{\});}

\end{DoxyCode}
\hypertarget{md_docs_2readme_autotoc_md14}{}\doxysubsection{\texorpdfstring{dynamic\+\_\+\texorpdfstring{$\ast$}{*} versions to keep classes as variables}{dynamic\+\_\+\texorpdfstring{$\ast$}{*} versions to keep classes as variables}}\label{md_docs_2readme_autotoc_md14}
Most of the classes inside rpp library including {\ttfamily observable}, {\ttfamily observer} and others are heavy-\/templated classes. It means, it could has a lot of template params. In most cases you shouldn\textquotesingle{}t worry about it due to it is purely internal problem.

But in some cases you want to keep observable or observer inside your classes or return it from function. In most cases I strongly recommend you to use {\ttfamily auto} to deduce type automatically. But in some cases it is not possible (for example, to keep observable as member variable). For such an usage you could use {\ttfamily dynamic\+\_\+observable} and {\ttfamily dynamic\+\_\+observer}\+:
\begin{DoxyItemize}
\item they are type-\/erased wrappers over regular observable/observer with goal to hide all unnecessary stuff from user\textquotesingle{}s code. For example, you can easily use it as\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <rpp/rpp.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct\ }some\_data}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classrpp_1_1dynamic__observable}{rpp::dynamic\_observable<int>}}\ observable;}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classrpp_1_1dynamic__observer}{rpp::dynamic\_observer<int>}}\ observer;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()\ \{}
\DoxyCodeLine{\ \ \ \ some\_data\ v\{\mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(1,2,3),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{group__observers_gae17f62f64102925f4cd2eb29c4c27028}{rpp::make\_lambda\_observer}}([](\textcolor{keywordtype}{int}\ value)\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ value\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \})\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ v.observable.subscribe(v.observer);}
\DoxyCodeLine{\}}

\end{DoxyCode}

\item to convert observable/observer to dynamic\+\_\+\texorpdfstring{$\ast$}{*} version you could manually call {\ttfamily as\+\_\+dynamic()} member function or just pass them to ctor
\item actually they are similar to rxcpp\textquotesingle{}s {\ttfamily observer\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} and {\ttfamily observable\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} but provides EXPLICIT definition of {\ttfamily dynamic} fact
\item due to type-\/erasure mechanism {\ttfamily dynamic\+\_\+} provides some minor performance penalties due to extra usage of {\ttfamily shared\+\_\+ptr} to keep internal state + indirect calls. It is not critical in case of storing it as member function, but could be important in case of using it on hot paths like this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(1,2,3)}
\DoxyCodeLine{|\ rpp::ops::map([](\textcolor{keywordtype}{int}\ v)\ \{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(v);\ \})}
\DoxyCodeLine{|\ rpp::ops::flat\_map([](\mbox{\hyperlink{classrpp_1_1dynamic__observable}{rpp::dynamic\_observable<int>}}\ observable)\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ observable\ |\ rpp::ops::filter([](\textcolor{keywordtype}{int}\ v)\{\ \textcolor{keywordflow}{return}\ v\ \%\ 2\ ==\ 0;\});}
\DoxyCodeLine{\});}

\end{DoxyCode}
 \texorpdfstring{$^\wedge$}{\string^}\texorpdfstring{$^\wedge$}{\string^}\texorpdfstring{$^\wedge$}{\string^} while it is fully valid code, {\ttfamily flat\+\_\+map} have to convert observable to dynamic version via extra heap, but it is unnecessary. It is better to use {\ttfamily auto} in this case. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(1,2,3)}
\DoxyCodeLine{|\ rpp::ops::map([](\textcolor{keywordtype}{int}\ v)\ \{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{group__creational__operators_ga1edf47f176050dd414e28a1c0616b7c0}{rpp::source::just}}(v);\ \})}
\DoxyCodeLine{|\ rpp::ops::flat\_map([](\textcolor{keyword}{const}\ \mbox{\hyperlink{conceptrpp_1_1constraint_1_1observable__of__type}{rpp::constraint::observable\_of\_type<int>}}\ \textcolor{keyword}{auto}\&\ observable)\ \{\ \textcolor{comment}{//\ or\ just\ \`{}const\ auto\&\ observable`}}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ observable\ |\ rpp::ops::filter([](\textcolor{keywordtype}{int}\ v)\{\ \textcolor{keywordflow}{return}\ v\ \%\ 2\ ==\ 0;\});}
\DoxyCodeLine{\});}

\end{DoxyCode}
 
\end{DoxyItemize}
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReactivePlusPlus: Utility Operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ReactivePlusPlus
   </div>
   <div id="projectbrief">One more implementation of ReactiveX approach in C++ with care about performance and templates in mind</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__utility__operators.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Utility Operators<div class="ingroups"><a class="el" href="group__rpp.html">RPP</a> &raquo; <a class="el" href="group__operators.html">Operators</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Utility operators are operators that provide some extra functionality without changing of original values, but changing of behaviour.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf883140cd425aa10c6a314eb014fb9b"><td class="memTemplParams" colspan="2">template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;delay_tag, TScheduler&gt;</td></tr>
<tr class="memitem:gaaf883140cd425aa10c6a314eb014fb9b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#gaaf883140cd425aa10c6a314eb014fb9b">observable::delay</a> (auto &amp;&amp;delay_duration, TScheduler &amp;&amp;scheduler) const &amp;</td></tr>
<tr class="memdesc:gaaf883140cd425aa10c6a314eb014fb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the emissions from an Observable forward in time by a particular amount.  <br /></td></tr>
<tr class="separator:gaaf883140cd425aa10c6a314eb014fb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134878936c20b1ef87d3c655ceffc131"><td class="memTemplParams" colspan="2">template&lt;constraint::observer_of_type&lt; Type &gt; TObs&gt; <br />
requires is_header_included &lt;do_tag, TObs&gt;</td></tr>
<tr class="memitem:ga134878936c20b1ef87d3c655ceffc131"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga134878936c20b1ef87d3c655ceffc131">observable::tap</a> (TObs &amp;&amp;observer) const &amp;</td></tr>
<tr class="memdesc:ga134878936c20b1ef87d3c655ceffc131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an observer to be called when observable provides any events (on_next/on_error/on_completed)  <br /></td></tr>
<tr class="separator:ga134878936c20b1ef87d3c655ceffc131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga345385e805cd439432d447065727df09"><td class="memTemplParams" colspan="2">template&lt;constraint::on_next_fn&lt; Type &gt; OnNextFn, constraint::on_error_fn OnErrorFn = utils::empty_function_t&lt;std::exception_ptr&gt;, constraint::on_completed_fn OnCompletedFn = utils::empty_function_t&lt;&gt;&gt; <br />
requires is_header_included &lt;do_tag, OnNextFn, OnErrorFn, OnCompletedFn&gt;</td></tr>
<tr class="memitem:ga345385e805cd439432d447065727df09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga345385e805cd439432d447065727df09">observable::tap</a> (OnNextFn &amp;&amp;on_next, OnErrorFn &amp;&amp;on_error=OnErrorFn{}, OnCompletedFn &amp;&amp;on_completed=OnCompletedFn{}) const &amp;</td></tr>
<tr class="memdesc:ga345385e805cd439432d447065727df09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an list of actions to be called when observable provides any events (on_next/on_error/on_completed)  <br /></td></tr>
<tr class="separator:ga345385e805cd439432d447065727df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e80d15de566a980aa0ddcb2c529977f"><td class="memTemplParams" colspan="2">template&lt;constraint::on_next_fn&lt; Type &gt; OnNextFn&gt; <br />
requires is_header_included &lt;do_tag, OnNextFn&gt;</td></tr>
<tr class="memitem:ga1e80d15de566a980aa0ddcb2c529977f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga1e80d15de566a980aa0ddcb2c529977f">observable::do_on_next</a> (OnNextFn &amp;&amp;on_next) const &amp;</td></tr>
<tr class="memdesc:ga1e80d15de566a980aa0ddcb2c529977f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an callback to be called when observable provides new item (on_next)  <br /></td></tr>
<tr class="separator:ga1e80d15de566a980aa0ddcb2c529977f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9089d55867fc04d1f353dc636e519634"><td class="memTemplParams" colspan="2">template&lt;constraint::on_error_fn OnErrorFn&gt; <br />
requires is_header_included &lt;do_tag, OnErrorFn&gt;</td></tr>
<tr class="memitem:ga9089d55867fc04d1f353dc636e519634"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga9089d55867fc04d1f353dc636e519634">observable::do_on_error</a> (OnErrorFn &amp;&amp;on_error) const &amp;</td></tr>
<tr class="memdesc:ga9089d55867fc04d1f353dc636e519634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an callback to be called when observable provides error (on_error)  <br /></td></tr>
<tr class="separator:ga9089d55867fc04d1f353dc636e519634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d6dfc49bf54893033b45b530f0fcb38"><td class="memTemplParams" colspan="2">template&lt;constraint::on_completed_fn OnCompletedFn&gt; <br />
requires is_header_included &lt;do_tag, OnCompletedFn&gt;</td></tr>
<tr class="memitem:ga2d6dfc49bf54893033b45b530f0fcb38"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga2d6dfc49bf54893033b45b530f0fcb38">observable::do_on_completed</a> (OnCompletedFn &amp;&amp;on_completed) const &amp;</td></tr>
<tr class="memdesc:ga2d6dfc49bf54893033b45b530f0fcb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an callback to be called when observable provides complete (on_completed)  <br /></td></tr>
<tr class="separator:ga2d6dfc49bf54893033b45b530f0fcb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374d453301a31f00fed7024be4327934"><td class="memTemplParams" colspan="2">template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;observe_on_tag, TScheduler&gt;</td></tr>
<tr class="memitem:ga374d453301a31f00fed7024be4327934"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga374d453301a31f00fed7024be4327934">observable::observe_on</a> (TScheduler &amp;&amp;scheduler) const &amp;</td></tr>
<tr class="memdesc:ga374d453301a31f00fed7024be4327934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit emissions of observable starting from this point via provided scheduler.  <br /></td></tr>
<tr class="separator:ga374d453301a31f00fed7024be4327934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a165810b188f9cf9b77255ed725e31a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires is_header_included&lt;repeat_tag, Args...&gt;</td></tr>
<tr class="memitem:ga2a165810b188f9cf9b77255ed725e31a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga2a165810b188f9cf9b77255ed725e31a">observable::repeat</a> (size_t count) const &amp;</td></tr>
<tr class="memdesc:ga2a165810b188f9cf9b77255ed725e31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-subscribes on current observable during <code>on_completed</code> provided amount of times.  <br /></td></tr>
<tr class="separator:ga2a165810b188f9cf9b77255ed725e31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152a343d0ea926ee04cf64ebb78c5d5e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires is_header_included&lt;repeat_tag, Args...&gt;</td></tr>
<tr class="memitem:ga152a343d0ea926ee04cf64ebb78c5d5e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga152a343d0ea926ee04cf64ebb78c5d5e">observable::repeat</a> () const &amp;</td></tr>
<tr class="memdesc:ga152a343d0ea926ee04cf64ebb78c5d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-subscribes on current observable during <code>on_completed</code> infinitely.  <br /></td></tr>
<tr class="separator:ga152a343d0ea926ee04cf64ebb78c5d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2272435c76e0830c70e111b3270cd3d4"><td class="memTemplParams" colspan="2">template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;subscribe_on_tag, TScheduler&gt;</td></tr>
<tr class="memitem:ga2272435c76e0830c70e111b3270cd3d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga2272435c76e0830c70e111b3270cd3d4">observable::subscribe_on</a> (const TScheduler &amp;scheduler) const &amp;</td></tr>
<tr class="memdesc:ga2272435c76e0830c70e111b3270cd3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">OnSubscribe function for this observable will be scheduled via provided scheduler.  <br /></td></tr>
<tr class="separator:ga2272435c76e0830c70e111b3270cd3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4266aff14b3f5313031cca946369ea25"><td class="memTemplParams" colspan="2">template&lt;constraint::observable_of_type&lt; Type &gt; FallbackObs, schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;timeout_tag, FallbackObs, TScheduler&gt;</td></tr>
<tr class="memitem:ga4266aff14b3f5313031cca946369ea25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga4266aff14b3f5313031cca946369ea25">observable::timeout</a> (schedulers::duration period, FallbackObs &amp;&amp;fallback_obs, const TScheduler &amp;scheduler=TScheduler{}) const &amp;</td></tr>
<tr class="memdesc:ga4266aff14b3f5313031cca946369ea25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards emissions from original observable, but subscribes on fallback observable if no any events during specified period of time (since last emission)  <br /></td></tr>
<tr class="separator:ga4266aff14b3f5313031cca946369ea25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae93d14e68fd17524ebc1ac48e6bf35f"><td class="memTemplParams" colspan="2">template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;timeout_tag, TScheduler&gt;</td></tr>
<tr class="memitem:gaae93d14e68fd17524ebc1ac48e6bf35f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#gaae93d14e68fd17524ebc1ac48e6bf35f">observable::timeout</a> (schedulers::duration period, const TScheduler &amp;scheduler=TScheduler{}) const &amp;</td></tr>
<tr class="memdesc:gaae93d14e68fd17524ebc1ac48e6bf35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards emissions from original observable, but emit error if no any events during specified period of time (since last emission)  <br /></td></tr>
<tr class="separator:gaae93d14e68fd17524ebc1ac48e6bf35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Utility operators are operators that provide some extra functionality without changing of original values, but changing of behaviour. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators.html#utility">https://reactivex.io/documentation/operators.html#utility</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaf883140cd425aa10c6a314eb014fb9b" name="gaaf883140cd425aa10c6a314eb014fb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf883140cd425aa10c6a314eb014fb9b">&#9670;&#160;</a></span>delay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;delay_tag, TScheduler&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::delay </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>delay_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScheduler &amp;&amp;&#160;</td>
          <td class="paramname"><em>scheduler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the emissions from an Observable forward in time by a particular amount. </p>
<p>The delay operator modifies its source Observable by pausing for a particular increment of time (that you specify) before emitting each of the source Observableâ€™s items. This has the effect of shifting the entire sequence of items emitted by the Observable forward in time by that specified increment.</p>
<div class="image">
<object type="image/svg+xml" data="delay.svg" style="pointer-events: none;"></object>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay_duration</td><td>is the delay duration for emitting items. Delay duration should be able to cast to rpp::schedulers::duration. </td></tr>
    <tr><td class="paramname">scheduler</td><td>provides the threading model for delay. e.g. With a new thread scheduler, the observer sees the values in a new thread after a delay duration to the subscription. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the delay operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="delay_8hpp_source.html">rpp/operators/delay.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> start = rpp::schedulers::clock_type::now();</div>
<div class="line"> </div>
<div class="line">    rpp::source::just(1, 2, 3)</div>
<div class="line">            .do_on_next([&amp;](<span class="keyword">auto</span>&amp;&amp; v)</div>
<div class="line">                        {</div>
<div class="line">                            <span class="keyword">auto</span> emitting_time = rpp::schedulers::clock_type::now();</div>
<div class="line">                            std::cout &lt;&lt; <span class="stringliteral">&quot;emit &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(emitting_time - start).count() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span>&lt;&lt; std::endl;</div>
<div class="line">                        })</div>
<div class="line">            .<a class="code hl_function" href="group__utility__operators.html#gaaf883140cd425aa10c6a314eb014fb9b">delay</a>(std::chrono::seconds{3}, <a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            .as_blocking()</div>
<div class="line">            .subscribe([&amp;](<span class="keywordtype">int</span> v)</div>
<div class="line">                       {</div>
<div class="line">                           <span class="keyword">auto</span> observing_time = rpp::schedulers::clock_type::now();</div>
<div class="line">                           std::cout &lt;&lt; <span class="stringliteral">&quot;observe &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(observing_time - start).count() &lt;&lt;<span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                       });</div>
<div class="line">    <span class="comment">// Template for output:</span></div>
<div class="line">    <span class="comment">//    emit 1 in thread{11772} duration since start 0s</span></div>
<div class="line">    <span class="comment">//    emit 2 in thread{11772} duration since start 0s</span></div>
<div class="line">    <span class="comment">//    emit 3 in thread{11772} duration since start 0s</span></div>
<div class="line">    <span class="comment">//    observe 1 in thread{15516} duration since start 3s</span></div>
<div class="line">    <span class="comment">//    observe 2 in thread{15516} duration since start 3s</span></div>
<div class="line">    <span class="comment">//    observe 3 in thread{15516} duration since start 3s</span></div>
<div class="ttc" id="aclassrpp_1_1schedulers_1_1new__thread_html"><div class="ttname"><a href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a></div><div class="ttdoc">scheduler which schedules execution of schedulables via queueing tasks to another thread with priorit...</div><div class="ttdef"><b>Definition:</b> new_thread_scheduler.hpp:32</div></div>
<div class="ttc" id="agroup__utility__operators_html_gaaf883140cd425aa10c6a314eb014fb9b"><div class="ttname"><a href="group__utility__operators.html#gaaf883140cd425aa10c6a314eb014fb9b">observable::delay</a></div><div class="ttdeci">auto delay(auto &amp;&amp;delay_duration, TScheduler &amp;&amp;scheduler) const &amp;</div><div class="ttdoc">Shift the emissions from an Observable forward in time by a particular amount.</div><div class="ttdef"><b>Definition:</b> delay.hpp:48</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/delay.html">https://reactivex.io/documentation/operators/delay.html</a> </dd></dl>

</div>
</div>
<a id="ga2d6dfc49bf54893033b45b530f0fcb38" name="ga2d6dfc49bf54893033b45b530f0fcb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d6dfc49bf54893033b45b530f0fcb38">&#9670;&#160;</a></span>do_on_completed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::on_completed_fn OnCompletedFn&gt; <br />
requires is_header_included &lt;do_tag, OnCompletedFn&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::do_on_completed </td>
          <td>(</td>
          <td class="paramtype">OnCompletedFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_completed</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an callback to be called when observable provides complete (on_completed) </p>
<dl class="section note"><dt>Note</dt><dd>on_completed from <code>tap</code> would be invoked BEFORE on_completed from subscriber</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_completed</td><td>- action in case of completion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the do_on_completed operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="do_8hpp_source.html">rpp/operators/do.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::empty&lt;int&gt;()</div>
<div class="line">            .do_on_completed([]() { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) Completed&quot;</span> &lt;&lt; std::endl; })</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span>) {}, []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// (TAP) Completed</span></div>
<div class="line">    <span class="comment">// Completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga9089d55867fc04d1f353dc636e519634" name="ga9089d55867fc04d1f353dc636e519634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9089d55867fc04d1f353dc636e519634">&#9670;&#160;</a></span>do_on_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::on_error_fn OnErrorFn&gt; <br />
requires is_header_included &lt;do_tag, OnErrorFn&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::do_on_error </td>
          <td>(</td>
          <td class="paramtype">OnErrorFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_error</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an callback to be called when observable provides error (on_error) </p>
<dl class="section note"><dt>Note</dt><dd>on_error from <code>tap</code> would be invoked BEFORE on_error from subscriber</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_error</td><td>- action over std::exception_ptr in case of any error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the do_on_error operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="do_8hpp_source.html">rpp/operators/do.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::error&lt;int&gt;(std::make_exception_ptr(std::runtime_error{<span class="stringliteral">&quot;&quot;</span>}))</div>
<div class="line">            .do_on_error([](std::exception_ptr) { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) NEW error&quot;</span> &lt;&lt; std::endl; })</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span>                 ) {}, [](std::exception_ptr) { std::cout &lt;&lt; <span class="stringliteral">&quot;NEW error&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// (TAP) NEW error</span></div>
<div class="line">    <span class="comment">// NEW error</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga1e80d15de566a980aa0ddcb2c529977f" name="ga1e80d15de566a980aa0ddcb2c529977f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e80d15de566a980aa0ddcb2c529977f">&#9670;&#160;</a></span>do_on_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::on_next_fn&lt; Type &gt; OnNextFn&gt; <br />
requires is_header_included &lt;do_tag, OnNextFn&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::do_on_next </td>
          <td>(</td>
          <td class="paramtype">OnNextFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_next</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an callback to be called when observable provides new item (on_next) </p>
<dl class="section note"><dt>Note</dt><dd>on_next from <code>tap</code> would be invoked BEFORE on_next from subscriber</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_next</td><td>- action over new emitted item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the do_on_next operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="do_8hpp_source.html">rpp/operators/do.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2)</div>
<div class="line">            .do_on_next([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; })</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span>  v) { std::cout &lt;&lt; <span class="stringliteral">&quot;NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                       []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 1</span></div>
<div class="line">    <span class="comment">// NEW item 1</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 2</span></div>
<div class="line">    <span class="comment">// NEW item 2</span></div>
<div class="line">    <span class="comment">// Completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga374d453301a31f00fed7024be4327934" name="ga374d453301a31f00fed7024be4327934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga374d453301a31f00fed7024be4327934">&#9670;&#160;</a></span>observe_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;observe_on_tag, TScheduler&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::observe_on </td>
          <td>(</td>
          <td class="paramtype">TScheduler &amp;&amp;&#160;</td>
          <td class="paramname"><em>scheduler</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit emissions of observable starting from this point via provided scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>is scheduler used for scheduling of OnNext </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the observe_on operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="observe__on_8hpp_source.html">rpp/operators/observe_on.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</div>
<div class="line">    rpp::source::just(10, 15, 20)</div>
<div class="line">            .observe_on(<a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            .as_blocking()</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;] : &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; });</div>
<div class="line">    <span class="comment">// Template for output:</span></div>
<div class="line">    <span class="comment">// TH1</span></div>
<div class="line">    <span class="comment">// [TH2]: 10</span></div>
<div class="line">    <span class="comment">// [TH2]: 15</span></div>
<div class="line">    <span class="comment">// [TH2]: 20</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/observeon.html">https://reactivex.io/documentation/operators/observeon.html</a> </dd></dl>

</div>
</div>
<a id="ga152a343d0ea926ee04cf64ebb78c5d5e" name="ga152a343d0ea926ee04cf64ebb78c5d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152a343d0ea926ee04cf64ebb78c5d5e">&#9670;&#160;</a></span>repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires is_header_included&lt;repeat_tag, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::repeat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-subscribes on current observable during <code>on_completed</code> infinitely. </p>
<div class="image">
<object type="image/svg+xml" data="repeat_infinitely.svg" style="pointer-events: none;"></object>
</div>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the repeat operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="repeat_8hpp_source.html">rpp/operators/repeat.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples:</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2, 3)</div>
<div class="line">            .repeat()</div>
<div class="line">            .take(10)</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; },</div>
<div class="line">                       []()</div>
<div class="line">                       {</div>
<div class="line">                           std::cout &lt;&lt; <span class="stringliteral">&quot;completed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                       });</div>
<div class="line">    <span class="comment">// Output: 1 2 3 1 2 3 1 2 3 1 completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/repeat.html">https://reactivex.io/documentation/operators/repeat.html</a> </dd></dl>

</div>
</div>
<a id="ga2a165810b188f9cf9b77255ed725e31a" name="ga2a165810b188f9cf9b77255ed725e31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a165810b188f9cf9b77255ed725e31a">&#9670;&#160;</a></span>repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires is_header_included&lt;repeat_tag, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::repeat </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-subscribes on current observable during <code>on_completed</code> provided amount of times. </p>
<div class="image">
<object type="image/svg+xml" data="repeat.svg" style="pointer-events: none;"></object>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>total amount of times subscription happens. For example:<ul>
<li><code>count(0)</code> - means no any subscription at all</li>
<li><code>count(1)</code> - behave like ordinal observable</li>
<li><code>count(10)</code> - 1 normal subscription and 9 re-subscriptions during on_completed </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the repeat operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="repeat_8hpp_source.html">rpp/operators/repeat.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples:</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2, 3)</div>
<div class="line">            .repeat(2)</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; },</div>
<div class="line">                       []()</div>
<div class="line">                       {</div>
<div class="line">                           std::cout &lt;&lt; <span class="stringliteral">&quot;completed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                       });</div>
<div class="line">    <span class="comment">// Output: 1 2 3 1 2 3 completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/repeat.html">https://reactivex.io/documentation/operators/repeat.html</a> </dd></dl>

</div>
</div>
<a id="ga2272435c76e0830c70e111b3270cd3d4" name="ga2272435c76e0830c70e111b3270cd3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2272435c76e0830c70e111b3270cd3d4">&#9670;&#160;</a></span>subscribe_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;subscribe_on_tag, TScheduler&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::subscribe_on </td>
          <td>(</td>
          <td class="paramtype">const TScheduler &amp;&#160;</td>
          <td class="paramname"><em>scheduler</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OnSubscribe function for this observable will be scheduled via provided scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>is scheduler used for scheduling of OnSubscribe </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the subscribe_on operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="subscribe__on_8hpp_source.html">rpp/operators/subscribe_on.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</div>
<div class="line">    rpp::source::create&lt;int&gt;([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sub)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;on_subscribe thread &quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</div>
<div class="line">                sub.on_next(1);</div>
<div class="line">                sub.on_completed();</div>
<div class="line">            })</div>
<div class="line">            .<a class="code hl_function" href="group__utility__operators.html#ga2272435c76e0830c70e111b3270cd3d4">subscribe_on</a>(<a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            .as_blocking()</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;] : &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; });</div>
<div class="line">    <span class="comment">// Template for output:</span></div>
<div class="line">    <span class="comment">// TH1</span></div>
<div class="line">    <span class="comment">// on_subscribe thread TH2</span></div>
<div class="line">    <span class="comment">// [TH2]: 1</span></div>
<div class="ttc" id="agroup__utility__operators_html_ga2272435c76e0830c70e111b3270cd3d4"><div class="ttname"><a href="group__utility__operators.html#ga2272435c76e0830c70e111b3270cd3d4">observable::subscribe_on</a></div><div class="ttdeci">auto subscribe_on(const TScheduler &amp;scheduler) const &amp;</div><div class="ttdoc">OnSubscribe function for this observable will be scheduled via provided scheduler.</div><div class="ttdef"><b>Definition:</b> subscribe_on.hpp:44</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/subscribeon.html">https://reactivex.io/documentation/operators/subscribeon.html</a> </dd></dl>

</div>
</div>
<a id="ga345385e805cd439432d447065727df09" name="ga345385e805cd439432d447065727df09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga345385e805cd439432d447065727df09">&#9670;&#160;</a></span>tap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::on_next_fn&lt; Type &gt; OnNextFn, constraint::on_error_fn OnErrorFn = utils::empty_function_t&lt;std::exception_ptr&gt;, constraint::on_completed_fn OnCompletedFn = utils::empty_function_t&lt;&gt;&gt; <br />
requires is_header_included &lt;do_tag, OnNextFn, OnErrorFn, OnCompletedFn&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::tap </td>
          <td>(</td>
          <td class="paramtype">OnNextFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnErrorFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_error</em> = <code>OnErrorFn{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnCompletedFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_completed</em> = <code>OnCompletedFn{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an list of actions to be called when observable provides any events (on_next/on_error/on_completed) </p>
<dl class="section note"><dt>Note</dt><dd>Callbacks from <code>tap</code> would be invoked BEFORE subscribed subscriber</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_next</td><td>- action over new emitted item </td></tr>
    <tr><td class="paramname">on_error</td><td>- action over std::exception_ptr in case of any error </td></tr>
    <tr><td class="paramname">on_completed</td><td>- action in case of completion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the tap operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="do_8hpp_source.html">rpp/operators/do.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2)</div>
<div class="line">            .tap([](<span class="keywordtype">int</span>               v) { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                 [](std::exception_ptr) {},</div>
<div class="line">                 []() { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) Completed&quot;</span> &lt;&lt; std::endl; })</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                       []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 1</span></div>
<div class="line">    <span class="comment">// NEW item 1</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 2</span></div>
<div class="line">    <span class="comment">// NEW item 2</span></div>
<div class="line">    <span class="comment">// (TAP) Completed</span></div>
<div class="line">    <span class="comment">// Completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga134878936c20b1ef87d3c655ceffc131" name="ga134878936c20b1ef87d3c655ceffc131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga134878936c20b1ef87d3c655ceffc131">&#9670;&#160;</a></span>tap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::observer_of_type&lt; Type &gt; TObs&gt; <br />
requires is_header_included &lt;do_tag, TObs&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::tap </td>
          <td>(</td>
          <td class="paramtype">TObs &amp;&amp;&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an observer to be called when observable provides any events (on_next/on_error/on_completed) </p>
<dl class="section note"><dt>Note</dt><dd>Callbacks from <code>tap</code> would be invoked BEFORE subscribed subscriber</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>- observer which would accept callbacks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the tap operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="do_8hpp_source.html">rpp/operators/do.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2)</div>
<div class="line">            .tap(rpp::make_specific_observer&lt;int&gt;([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                                                  []() { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) Completed&quot;</span> &lt;&lt; std::endl; }))</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                       []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 1</span></div>
<div class="line">    <span class="comment">// NEW item 1</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 2</span></div>
<div class="line">    <span class="comment">// NEW item 2</span></div>
<div class="line">    <span class="comment">// (TAP) Completed</span></div>
<div class="line">    <span class="comment">// Completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="gaae93d14e68fd17524ebc1ac48e6bf35f" name="gaae93d14e68fd17524ebc1ac48e6bf35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae93d14e68fd17524ebc1ac48e6bf35f">&#9670;&#160;</a></span>timeout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;timeout_tag, TScheduler&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::timeout </td>
          <td>(</td>
          <td class="paramtype">schedulers::duration&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TScheduler &amp;&#160;</td>
          <td class="paramname"><em>scheduler</em> = <code>TScheduler{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards emissions from original observable, but emit error if no any events during specified period of time (since last emission) </p>
<div class="image">
<object type="image/svg+xml" data="timeout.svg" style="pointer-events: none;"></object>
</div>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>is maximum duration between emitted items before a timeout occurs </td></tr>
    <tr><td class="paramname">scheduler</td><td>is scheduler used to run timer for timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the timeout operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="timeout_8hpp_source.html">rpp/operators/timeout.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">        <a class="code hl_class" href="classrpp_1_1subjects_1_1publish__subject.html">rpp::subjects::publish_subject&lt;int&gt;</a> subj{};</div>
<div class="line">        subj.get_observable()</div>
<div class="line">            .timeout(std::chrono::milliseconds{450}, <a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span>                v) { std::cout &lt;&lt; <span class="stringliteral">&quot;new value &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                       [](std::exception_ptr err)</div>
<div class="line">                       {</div>
<div class="line">                           <span class="keywordflow">try</span></div>
<div class="line">                           {</div>
<div class="line">                               std::rethrow_exception(err);</div>
<div class="line">                           }</div>
<div class="line">                           <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; exc)</div>
<div class="line">                           {</div>
<div class="line">                               std::cout &lt;&lt; <span class="stringliteral">&quot;ERR: &quot;</span> &lt;&lt; exc.what() &lt;&lt; std::endl;</div>
<div class="line">                           }</div>
<div class="line">                       },</div>
<div class="line">                       []() { std::cout &lt;&lt; <span class="stringliteral">&quot;completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i)</div>
<div class="line">        {</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds{i * 100});</div>
<div class="line">            subj.get_subscriber().on_next(i);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Output:</span></div>
<div class="line">        <span class="comment">// new value 0</span></div>
<div class="line">        <span class="comment">// new value 1</span></div>
<div class="line">        <span class="comment">// new value 2</span></div>
<div class="line">        <span class="comment">// new value 3</span></div>
<div class="line">        <span class="comment">// new value 4</span></div>
<div class="line">        <span class="comment">// ERR : Timeout reached</span></div>
<div class="ttc" id="aclassrpp_1_1subjects_1_1publish__subject_html"><div class="ttname"><a href="classrpp_1_1subjects_1_1publish__subject.html">rpp::subjects::publish_subject</a></div><div class="ttdoc">Subject which just multicasts values to observers subscribed on it. It contains two parts: subscriber...</div><div class="ttdef"><b>Definition:</b> publish_subject.hpp:78</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/timeout.html">https://reactivex.io/documentation/operators/timeout.html</a> </dd></dl>

</div>
</div>
<a id="ga4266aff14b3f5313031cca946369ea25" name="ga4266aff14b3f5313031cca946369ea25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4266aff14b3f5313031cca946369ea25">&#9670;&#160;</a></span>timeout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::observable_of_type&lt; Type &gt; FallbackObs, schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;timeout_tag, FallbackObs, TScheduler&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::timeout </td>
          <td>(</td>
          <td class="paramtype">schedulers::duration&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FallbackObs &amp;&amp;&#160;</td>
          <td class="paramname"><em>fallback_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TScheduler &amp;&#160;</td>
          <td class="paramname"><em>scheduler</em> = <code>TScheduler{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards emissions from original observable, but subscribes on fallback observable if no any events during specified period of time (since last emission) </p>
<div class="image">
<object type="image/svg+xml" data="timeout_fallback_obs.svg" style="pointer-events: none;"></object>
</div>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>is maximum duration between emitted items before a timeout occurs </td></tr>
    <tr><td class="paramname">fallback_obs</td><td>is observable to subscribe on when timeout reached </td></tr>
    <tr><td class="paramname">scheduler</td><td>is scheduler used to run timer for timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the timeout operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="timeout_8hpp_source.html">rpp/operators/timeout.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">        <a class="code hl_class" href="classrpp_1_1subjects_1_1publish__subject.html">rpp::subjects::publish_subject&lt;int&gt;</a> subj{};</div>
<div class="line">        subj.get_observable()</div>
<div class="line">            .timeout(std::chrono::milliseconds{450}, rpp::source::just(100), <a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span>                v) { std::cout &lt;&lt; <span class="stringliteral">&quot;new value &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                       []() { std::cout &lt;&lt; <span class="stringliteral">&quot;completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i)</div>
<div class="line">        {</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds{i * 100});</div>
<div class="line">            subj.get_subscriber().on_next(i);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Output:</span></div>
<div class="line">        <span class="comment">//new value 0</span></div>
<div class="line">        <span class="comment">//new value 1</span></div>
<div class="line">        <span class="comment">//new value 2</span></div>
<div class="line">        <span class="comment">//new value 3</span></div>
<div class="line">        <span class="comment">//new value 4</span></div>
<div class="line">        <span class="comment">//new value 100</span></div>
<div class="line">        <span class="comment">//completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/timeout.html">https://reactivex.io/documentation/operators/timeout.html</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>

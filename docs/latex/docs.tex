
\begin{DoxyItemize}
\item \mbox{\hyperlink{quick_start}{Quick Start}} -\/ fast overview how to work with R\+PP
\item \mbox{\hyperlink{advanced}{Advanced Guide}} -\/ everything about R\+PP in details
\item \mbox{\hyperlink{specific_vs_dynamic}{Performance vs Flexibility\+: Specific vs Dynamic}} -\/ overview of the concept of {\ttfamily specific\+\_\+} and {\ttfamily dynamic\+\_\+} types used in {\bfseries{R\+PP}} and how it affects performance
\item \mbox{\hyperlink{memory_model}{Memory Model}} -\/ overview of new concept used in R\+PP related to copy/move/heap usage for objects passed inside R\+PP
\item \mbox{\hyperlink{exception_guarantee}{Exception guarantee}} -\/ overview of exception guarantees provided by R\+PP
\item \mbox{\hyperlink{status}{Implementation status}} -\/ current implementation status 
\end{DoxyItemize}\hypertarget{quick_start}{}\doxysection{Quick Start}\label{quick_start}
\hypertarget{quick_start_autotoc_md22}{}\doxysubsection{Brief workflow}\label{quick_start_autotoc_md22}
For the brief overview of the Reactive pattern read \href{https://reactivex.io/}{\texttt{ https\+://reactivex.\+io/}}.

In short, creation of programs with help of Reactive\+Plus\+Plus split into several parts\+:\hypertarget{quick_start_autotoc_md23}{}\doxysubsubsection{1) Define observables}\label{quick_start_autotoc_md23}
Observables are sources of your future streams. First of all you need to create some observable which emits values. You can select from some \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/group__creational__operators.html}{\texttt{ predefined}} or built your own.

For example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{rpp::source::from\_callable(\&::getchar)}
\end{DoxyCode}


observable which emits one char from {\ttfamily cin} via invoking of provided function once after subscription

Action inside observable happens O\+N\+LY after subscription on this observable and O\+N\+LY for provided subscriber/observer. It means, that you can subscribe on the same observable multiple times! But actually each of this subscriber would see its \char`\"{}own\char`\"{} observable -\/ function invoked especially for this one.\hypertarget{quick_start_autotoc_md24}{}\doxysubsubsection{2) Chain observable}\label{quick_start_autotoc_md24}
When you have some source of data you need to extend it somehow to make it useful! For example, let\textquotesingle{}s make it infinite instead of emitting one value\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{rpp::source::from\_callable(\&::getchar)}
\DoxyCodeLine{   .repeat()}
\end{DoxyCode}


Also we can filters out digits, transform rest chars to upper. We need to add


\begin{DoxyCode}{0}
\DoxyCodeLine{...}
\DoxyCodeLine{.filter(std::not\_fn(\&::isdigit))}
\DoxyCodeLine{.map(\&::toupper)}
\end{DoxyCode}


How long do we want to obtain values? let\textquotesingle{}s say, till \textquotesingle{}0\textquotesingle{} char. 
\begin{DoxyCode}{0}
\DoxyCodeLine{...}
\DoxyCodeLine{.take\_while([](\textcolor{keywordtype}{char} v) \{ \textcolor{keywordflow}{return} v != \textcolor{charliteral}{'0'}; \})}
\DoxyCodeLine{.filter(std::not\_fn(\&::isdigit))}
\DoxyCodeLine{.map(\&::toupper)}
\end{DoxyCode}
\hypertarget{quick_start_autotoc_md25}{}\doxysubsubsection{3) Subscription}\label{quick_start_autotoc_md25}
What we want to do with resulting values? Let\textquotesingle{}s dump it to console. Resulting code looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{rpp::source::from\_callable(\&::getchar)}
\DoxyCodeLine{    .repeat()}
\DoxyCodeLine{    .take\_while([](\textcolor{keywordtype}{char} v) \{ \textcolor{keywordflow}{return} v != \textcolor{charliteral}{'0'}; \})}
\DoxyCodeLine{    .filter(std::not\_fn(\&::isdigit))}
\DoxyCodeLine{    .map(\&::toupper)}
\DoxyCodeLine{    .subscribe([](\textcolor{keywordtype}{char} v) \{ std::cout << v; \});}
\end{DoxyCode}


Subscribe function applies any from\+:
\begin{DoxyItemize}
\item \mbox{[}none\mbox{]}
\item subscription
\item {\ttfamily on\+\_\+next}
\item subscription, {\ttfamily on\+\_\+next}
\item {\ttfamily on\+\_\+next}, {\ttfamily on\+\_\+error}
\item subscription, {\ttfamily on\+\_\+next}, {\ttfamily on\+\_\+error}
\item {\ttfamily on\+\_\+next}, {\ttfamily on\+\_\+completed}
\item subscription, {\ttfamily on\+\_\+next}, {\ttfamily on\+\_\+completed}
\item on\+\_\+next{\ttfamily ,}on\+\_\+erroron\+\_\+completed{\ttfamily }
\item {\ttfamily subscription,}on\+\_\+next{\ttfamily ,}on\+\_\+erroron\+\_\+completed\`{}
\item observer
\item subscription, observer 
\end{DoxyItemize}\hypertarget{advanced}{}\doxysection{Advanced Guide}\label{advanced}
\hypertarget{advanced_autotoc_md0}{}\doxysubsection{Beforehand}\label{advanced_autotoc_md0}
Before hand, please, read \mbox{\hyperlink{specific_vs_dynamic}{Performance vs Flexibility\+: Specific vs Dynamic}}

Also read this one\+: \href{https://reactivex.io/documentation/contract.html}{\texttt{ Contract}}

Let\textquotesingle{}s review this one in details\+: \begin{quote}
Observables must issue notifications to observers serially (not in parallel). They may issue these notifications from different threads, but there must be a formal happens-\/before relationship between the notifications. \end{quote}


It means, that\+:


\begin{DoxyEnumerate}
\item All operators implemented in R\+PP are following this contract and emissions from observables/operators built-\/in in R\+PP are serialized
\item All logic inside operator\textquotesingle{}s callbacks and observer can be not thread-\/safe due to thread-\/safety is guaranteed. (for example, {\ttfamily take} operator doesn\textquotesingle{}t use mutexes or atomics due to underlying observable {\bfseries{M\+U\+ST}} emit items serialized)
\item When you implement your own operator via {\ttfamily create} be careful to {\bfseries{follow this contract}}!
\item it is true {\bfseries{E\+X\+C\+E\+PT F\+OR}} subjects if they are used manually due to users can use subjects for its own purposes there is potentially place for breaking this concept. Be careful and use synchronized subjects!
\end{DoxyEnumerate}

It means, that for example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} s1 = \mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(1).repeat().subscribe\_on(\mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\});}
\DoxyCodeLine{\textcolor{keyword}{auto} s2 = \mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(2).repeat().subscribe\_on(\mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\});}
\DoxyCodeLine{s1.merge\_with(s2).map([](\textcolor{keywordtype}{int} v)\{}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"enter "} << v << std::endl;}
\DoxyCodeLine{    std::this\_thread::sleep\_for(std::chrono::seconds\{1\});}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"exit "} << v << std::endl;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{\}).as\_blocking().subscribe([](\textcolor{keywordtype}{int})\{\});}
\end{DoxyCode}


will never produce something like 
\begin{DoxyCode}{0}
\DoxyCodeLine{enter 1}
\DoxyCodeLine{enter 2}
\DoxyCodeLine{exit 2}
\DoxyCodeLine{exit 1}
\end{DoxyCode}


only serialized 
\begin{DoxyCode}{0}
\DoxyCodeLine{enter 1}
\DoxyCodeLine{exit 1}
\DoxyCodeLine{enter 1}
\DoxyCodeLine{exit 1}
\DoxyCodeLine{enter 2}
\DoxyCodeLine{exit 2}
\DoxyCodeLine{enter 2}
\DoxyCodeLine{exit 2}
\end{DoxyCode}
\hypertarget{advanced_autotoc_md1}{}\doxysubsection{Observable}\label{advanced_autotoc_md1}
Observables are just wrappers over callback function with ability to be extended via operators. Everytime you apply some operator to observable, observable is copied (or moved). As a result, whole its state is copied/moved too\+:


\begin{DoxyItemize}
\item be ready for it, so, your callback (or any state inside operators) should be cheap enough to copy
\item if you want to avoid it, you can convert your observable to dynamic\+: it forces to move observable to {\ttfamily shared\+\_\+ptr}, as a result, no any future copies/moves
\item some observables/operators have {\ttfamily memory\+\_\+model} (\mbox{\hyperlink{memory_model}{Memory Model}}) parameter to change strategy of handling your variable\+: keep to copy/move or move to shared\+\_\+ptr once
\end{DoxyItemize}

Everytime you subscribe subscriber observable just invokes callback for this subscriber and nothing else. It means, that actually observable do nothing and doesn\textquotesingle{}t emit values, {\bfseries{callback emits values}}.

To achieve better performance use {\ttfamily specific\+\_\+observable} while it is possible. Same for the argument of callback (for example, when you use {\ttfamily rpp\+::source\+::create})\+: use {\ttfamily const auto\&} for subscriber to avoid implicit conversion to dynamic subscriber.

By default, functional programming deals with immutable data and \char`\"{}pure functions\char`\"{}. Observable follows this principle, so, it can accept only const functions for callback. \hypertarget{advanced_autotoc_md2}{}\doxysubsection{Observers}\label{advanced_autotoc_md2}
Observer also follows this principle, so, it can accept only const functions for callbacks.\hypertarget{advanced_autotoc_md3}{}\doxysubsection{Operators}\label{advanced_autotoc_md3}
For better compilation speed each operator placed in each own header. Due to great desire to have dot operations inside observable, observable inherits implementation of operators via {\ttfamily member\+\_\+overload} hack\+: it forwards interface, but implementation placed in another file. It looks like wide-\/spread separation to cpp/hpp files.\hypertarget{advanced_autotoc_md4}{}\doxysubsection{Subscriber}\label{advanced_autotoc_md4}
Subscriber is just wrapper over observer with subscription. Everytime callback received, subscriber checks for subscription state and emits value to observer if subscription is still active. \hypertarget{specific_vs_dynamic}{}\doxysection{Performance vs Flexibility\+: Specific vs Dynamic}\label{specific_vs_dynamic}
\hypertarget{specific_vs_dynamic_autotoc_md26}{}\doxysubsection{Brief overview}\label{specific_vs_dynamic_autotoc_md26}
In general Reactive Extensions can be split into three main parts from the objects perspective\+:
\begin{DoxyItemize}
\item observable
\item observer
\item subscriber
\end{DoxyItemize}

Each of this objects obtains user-\/defined callbacks to call when some event happens (on\+\_\+subscribe, on\+\_\+next/on\+\_\+error/on\+\_\+completed and etc). To store it in C++ we have two ways with its own prons and cons\+:
\begin{DoxyItemize}
\item store it explicitly via template type
\begin{DoxyItemize}
\item \doxygenemoji{\+:heavy\+\_\+check\+\_\+mark\+:}{heavy_check_mark} No heap allocations
\item \doxygenemoji{\+:heavy\+\_\+check\+\_\+mark\+:}{heavy_check_mark} Fast invoking (with possible inlining)
\item \doxygenemoji{\+:x\+:}{x} Template parameter makes each instance \char`\"{}uniq\char`\"{}
\item \doxygenemoji{\+:x\+:}{x} No way to store it somehow in containers/class members without pain
\end{DoxyItemize}
\item use type-\/erasure mechanism
\begin{DoxyItemize}
\item \doxygenemoji{\+:heavy\+\_\+check\+\_\+mark\+:}{heavy_check_mark} Avoiding of template parameters
\item \doxygenemoji{\+:heavy\+\_\+check\+\_\+mark\+:}{heavy_check_mark} Easy to store in containers/class members/input arguments of functions
\item \doxygenemoji{\+:x\+:}{x} In most cases heap allocation during constrution
\item \doxygenemoji{\+:x\+:}{x} More usage of memory even for cheap objects (std\+::function or pointer to allocated type)
\item \doxygenemoji{\+:x\+:}{x} Indirect invoking (most probably via pointer or virtual functions)
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{specific_vs_dynamic_autotoc_md27}{}\doxysubsection{Reactive\+Plus\+Plus solution}\label{specific_vs_dynamic_autotoc_md27}
Reactive\+Plus\+Plus provides ability to use both of this ways to make usage experience optimal! Each of mentioned above core parts has two different specifications\+: {\ttfamily specific\+\_\+} and {\ttfamily dynamic\+\_\+}.

{\ttfamily specific\+\_\+} is default specialization which uses fully template approach to have best performance and memory consumption\+: each callback/used type specific as template parameter of this class {\ttfamily dynamic\+\_\+} specialization uses type-\/erasure mechanism with all resulting peformance and memory hits, but this specialization is useful if you want to store type as class member or place it inside containers and etc.

There detailed list with explanations\+:
\begin{DoxyItemize}
\item observables\+:
\begin{DoxyItemize}
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1specific__observable.html}{\texttt{ rpp\+::specific\+\_\+observable$<$\+T, On\+Subscribe\+Fn$>$}} -\/ Stores type of {\ttfamily on\+\_\+subscribe} callback explicitly via {\ttfamily On\+Subscribe} template type. Due to explicit type of callback such an observable can obtains A\+NY specialization of subscriber and A\+NY specialization of observers without construction of {\ttfamily dynamic\+\_\+} specializations
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1dynamic__observable.html}{\texttt{ rpp\+::dynamic\+\_\+observable$<$\+T$>$}} -\/ stores callback as shared\+\_\+ptr to base class of {\ttfamily \mbox{\hyperlink{classrpp_1_1specific__observable}{rpp\+::specific\+\_\+observable}}} and calling callback via virtual function. Due to this limitation this observable can obtain only {\ttfamily dynamic\+\_\+observer} and {\ttfamily dynamic\+\_\+subscriber}
\end{DoxyItemize}
\item observers
\begin{DoxyItemize}
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1specific__observer.html}{\texttt{ rpp\+::specific\+\_\+observer$<$\+T, On\+Next, On\+Error, On\+Completed$>$}} -\/ Stores types of {\ttfamily on\+\_\+next, on\+\_\+error and on\+\_\+completed} callbacks explicitly via {\ttfamily On\+Next, On\+Error, On\+Completed} template types.
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1dynamic__observer.html}{\texttt{ rpp\+::dynamic\+\_\+observer$<$\+T$>$}} -\/ stores callbacks as shared\+\_\+ptr to base class of {\ttfamily \mbox{\hyperlink{classrpp_1_1specific__observer}{rpp\+::specific\+\_\+observer}}} and calling callbacks via virtual functions.
\end{DoxyItemize}
\item subscribers\+:
\begin{DoxyItemize}
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1specific__subscriber.html}{\texttt{ rpp\+::specific\+\_\+subscriber$<$\+T, Observer$>$}} -\/ stores explicit underlying type of observer as {\ttfamily Observer} template type to avoid construction of \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1dynamic__observer.html}{\texttt{ rpp\+::dynamic\+\_\+observer}}.
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1dynamic__subscriber.html}{\texttt{ rpp\+::dynamic\+\_\+subscriber$<$\+T$>$}} -\/ uses \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1dynamic__observer.html}{\texttt{ rpp\+::dynamic\+\_\+observer}} type as underlying type for observer.
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{specific_vs_dynamic_autotoc_md28}{}\doxysubsection{Examples}\label{specific_vs_dynamic_autotoc_md28}
So, to achieve best performance avoid usage of {\ttfamily dynamic\+\_\+} specialization till you really need it or you want to avoid extra copies/moves of original objects captured inside callbacks and prefer one-\/time {\ttfamily shared\+\_\+ptr} allication instead. For example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} observable = rpp::observable::create<int>([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& subscriber)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    subscriber.on\_next(1);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto} observer = \mbox{\hyperlink{classrpp_1_1specific__observer}{rpp::specific\_observer}}\{[](\textcolor{keywordtype}{int} v)\{ std::cout << v;\}\};}
\DoxyCodeLine{observable.subscribe(observer);}
\DoxyCodeLine{\textcolor{comment}{// OR observable.subscribe([](int v)\{ std::cout << v;\});}}
\end{DoxyCode}


uses only {\bfseries{O\+NE heap allocation}} for {\ttfamily rpp\+::subscription} inside subscriber to store subscription state and no any other allocation happens. On the other hand 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//1 dynamic\_subscriber in observable}}
\DoxyCodeLine{\textcolor{keyword}{auto} observable = rpp::observable::create<int>([](\textcolor{keyword}{const} \mbox{\hyperlink{classrpp_1_1dynamic__subscriber}{rpp::dynamic\_subscriber<int>}}\& subscriber)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    subscriber.on\_next(1);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{observable.subscribe(\mbox{\hyperlink{classrpp_1_1specific__observer}{rpp::specific\_observer}}\{[](\textcolor{keywordtype}{int} v)\{ std::cout << v;\}\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//2 dynamic\_observable}}
\DoxyCodeLine{\mbox{\hyperlink{classrpp_1_1dynamic__observable}{rpp::dynamic\_observable}} observable = rpp::observable::create<int>([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& subscriber)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    subscriber.on\_next(1);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{observable.subscribe(\mbox{\hyperlink{classrpp_1_1specific__observer}{rpp::specific\_observer}}\{[](\textcolor{keywordtype}{int} v)\{ std::cout << v;\}\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//3 dynamic\_observer}}
\DoxyCodeLine{\textcolor{keyword}{auto} observable = rpp::observable::create<int>([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& subscriber)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    subscriber.on\_next(1);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{observable.subscribe(\mbox{\hyperlink{classrpp_1_1dynamic__observer}{rpp::dynamic\_observer}}\{[](\textcolor{keywordtype}{int} v)\{ std::cout << v;\}\});}
\end{DoxyCode}


all this samples uses extra heap allocations\+:
\begin{DoxyEnumerate}
\item explicitly specify type of subscriber inside observable as {\ttfamily dynamic\+\_\+} -\/$>$ {\ttfamily dynamic\+\_\+subscriber} created during {\ttfamily subscribe(...)} call which creates {\ttfamily dynamic\+\_\+observer} underhood -\/$>$ heap used to construct {\ttfamily dynamic\+\_\+observer}
\item {\ttfamily dynamic\+\_\+observable} constructed via heap allocation. This specizalization can obtain only {\ttfamily dynamic\+\_\+subscriber} -\/$>$ same as prev. example
\item {\ttfamily dynamic\+\_\+observer} constructed via heap allocation.
\end{DoxyEnumerate}

For detailed comparison of performance of different operations for {\ttfamily specific\+\_\+} and {\ttfamily dynamic\+\_\+} you can find in \href{https://victimsnino.github.io/ReactivePlusPlus/benchmark}{\texttt{ Continuous Benchmarking}} \hypertarget{memory_model}{}\doxysection{Memory Model}\label{memory_model}
\hypertarget{memory_model_autotoc_md20}{}\doxysubsection{Overview}\label{memory_model_autotoc_md20}
In Reactive\+Plus\+Plus there is new concept unique for this implementation\+: rpp\+::memory\+\_\+model\+:

Some of the operators and sources like {\ttfamily rpp\+::source\+::just} or {\ttfamily rpp\+::operators\+::start\+\_\+with} accepts user\textquotesingle{}s variables for usage. Some of this types can be such an expensive to copy or move and it would be preferable to copy it once to heap, but some other types (like P\+OD) are cheap enough and usage of heap would be overkill. But these variables should be saved inside somehow!

So, R\+PP provides ability to select strategy \char`\"{}how to deal with such a variables\char`\"{} via {\ttfamily rpp\+::memory\+\_\+model} enum.\hypertarget{memory_model_autotoc_md21}{}\doxysubsection{Examples}\label{memory_model_autotoc_md21}
For example, {\ttfamily rpp\+::source\+::just}


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(my\_custom\_variable);}
\end{DoxyCode}


by default {\ttfamily just} uses {\ttfamily rpp\+::memory\+\_\+model\+::use\+\_\+stack} and {\ttfamily my\+\_\+custom\+\_\+variable} would be copied and moved everywhere when needed. On the other hand


\begin{DoxyCode}{0}
\DoxyCodeLine{rpp::source::just<rpp::memory\_model::use\_shared>(my\_custom\_variable);}
\end{DoxyCode}


makes only 1 copy/move to shared\+\_\+ptr and then uses it instead.

As a a result, users can select preferable way of handling of their types. \hypertarget{exception_guarantee}{}\doxysection{Exception guarantee}\label{exception_guarantee}
\hypertarget{exception_guarantee_autotoc_md6}{}\doxysubsection{Overview}\label{exception_guarantee_autotoc_md6}
In non-\/reactive programming functions/modules throws exception in case of something invalid. As a result, user can catch it and handle it somehow while internal state of objects can be in some state (invalid/untouched/partly valid) and etc.

In reactive programming there is another way of exception mechanism\+: throwing exception as is from original place is useless. Notification about \char`\"{}something goes wrong\char`\"{} need to receive observer/subscriber, not owner of callstack. As a result, A\+NY exception obtained during emitting items and etc W\+O\+U\+LD be delivered to subscriber/observer via {\ttfamily on\+\_\+error} function and then unsubscribe happens. As a result, no any raw exceptions would be throws during using R\+PP. In case of emitting {\ttfamily on\+\_\+error} whole internal state of observable keeps valid but it doesn\textquotesingle{}t matter -\/ whole chain would be destroyed due to {\ttfamily on\+\_\+error} forces unsubscribe. Reactive catching mechanisms like {\ttfamily catch} or {\ttfamily retry} {\bfseries{re-\/subscribes}} on observable. it means, that new chain with new states would be created, not re-\/used existing one. \hypertarget{status}{}\doxysection{Implementation status}\label{status}
\hypertarget{status_autotoc_md7}{}\doxysubsection{Fundamentals}\label{status_autotoc_md7}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Observables
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Specific Observable
\item \mbox{[}x\mbox{]} Dynamic Observable
\item \mbox{[}x\mbox{]} Blocking Observable
\item \mbox{[}x\mbox{]} Connectable Observable
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} Observers
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Specific Observer
\item \mbox{[}x\mbox{]} Dynamic Observer
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} Subscribers
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Specific Subscriber
\item \mbox{[}x\mbox{]} Dynamic Subscriber
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} Subscriptions
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Composite Subscription
\item \mbox{[}x\mbox{]} Callback Subscription
\end{DoxyItemize}
\item \mbox{[} \mbox{]} Schedulers
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Immediate
\item \mbox{[}x\mbox{]} New Thread
\item \mbox{[}x\mbox{]} Current\+Thread/\+Trampoline
\item \mbox{[}x\mbox{]} Run\+Loop
\item \mbox{[} \mbox{]} Event\+Loop
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{status_autotoc_md8}{}\doxysubsection{Creating Observables}\label{status_autotoc_md8}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Create
\item \mbox{[}x\mbox{]} Just
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} + memory\+\_\+model
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} empty/never/error
\item \mbox{[} \mbox{]} from
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} iterable
\item \mbox{[} \mbox{]} future
\item \mbox{[} \mbox{]} promise
\item \mbox{[}x\mbox{]} callable
\item \mbox{[} \mbox{]} async
\end{DoxyItemize}
\item \mbox{[} \mbox{]} defer
\item \mbox{[}x\mbox{]} interval
\item \mbox{[} \mbox{]} range
\item \mbox{[} \mbox{]} repeat
\item \mbox{[} \mbox{]} timer
\end{DoxyItemize}\hypertarget{status_autotoc_md9}{}\doxysubsection{Operators}\label{status_autotoc_md9}
\hypertarget{status_autotoc_md10}{}\doxysubsubsection{Transforming}\label{status_autotoc_md10}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} map
\item \mbox{[}x\mbox{]} group\+\_\+by
\item \mbox{[}x\mbox{]} flat\+\_\+map
\item \mbox{[}x\mbox{]} scan
\item \mbox{[} \mbox{]} buffer
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} count
\begin{DoxyItemize}
\item \mbox{[} \mbox{]} skip
\end{DoxyItemize}
\item \mbox{[} \mbox{]} time
\item \mbox{[} \mbox{]} time\+\_\+or\+\_\+count
\end{DoxyItemize}
\item \mbox{[} \mbox{]} window
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} count
\begin{DoxyItemize}
\item \mbox{[} \mbox{]} skip
\end{DoxyItemize}
\item \mbox{[} \mbox{]} time
\item \mbox{[} \mbox{]} time\+\_\+or\+\_\+count
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{status_autotoc_md11}{}\doxysubsubsection{Filtering}\label{status_autotoc_md11}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} filter
\item \mbox{[}x\mbox{]} take
\item \mbox{[} \mbox{]} debounce
\item \mbox{[} \mbox{]} distinct
\begin{DoxyItemize}
\item \mbox{[} \mbox{]} distinct
\item \mbox{[}x\mbox{]} distinct\+\_\+until\+\_\+changed
\end{DoxyItemize}
\item \mbox{[} \mbox{]} element\+\_\+at
\item \mbox{[}x\mbox{]} first
\item \mbox{[} \mbox{]} ignore\+\_\+elements
\item \mbox{[}x\mbox{]} last
\item \mbox{[} \mbox{]} sample
\item \mbox{[}x\mbox{]} skip
\item \mbox{[} \mbox{]} skip\+\_\+last
\item \mbox{[}x\mbox{]} take\+\_\+last
\end{DoxyItemize}\hypertarget{status_autotoc_md12}{}\doxysubsubsection{Conditional}\label{status_autotoc_md12}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} take\+\_\+while
\item \mbox{[} \mbox{]} all
\item \mbox{[} \mbox{]} amb
\item \mbox{[} \mbox{]} contains
\item \mbox{[} \mbox{]} default\+\_\+if\+\_\+empty
\item \mbox{[} \mbox{]} sequence\+\_\+equal
\item \mbox{[} \mbox{]} skip\+\_\+until
\item \mbox{[} \mbox{]} skip\+\_\+while
\item \mbox{[}x\mbox{]} take\+\_\+until
\end{DoxyItemize}\hypertarget{status_autotoc_md13}{}\doxysubsubsection{Combining}\label{status_autotoc_md13}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} merge
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} observable of observables
\item \mbox{[}x\mbox{]} merge with
\item \mbox{[} \mbox{]} merge delay error
\end{DoxyItemize}
\item \mbox{[} \mbox{]} switch
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} switch\+\_\+map
\item \mbox{[}x\mbox{]} switch\+\_\+on\+\_\+next
\item \mbox{[} \mbox{]} switch\+\_\+if\+\_\+empty
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} with\+\_\+latest\+\_\+from
\item \mbox{[}x\mbox{]} start\+\_\+with
\item \mbox{[}x\mbox{]} combine\+\_\+latest
\item \mbox{[} \mbox{]} zip
\end{DoxyItemize}\hypertarget{status_autotoc_md14}{}\doxysubsubsection{Aggregate}\label{status_autotoc_md14}

\begin{DoxyItemize}
\item \mbox{[} \mbox{]} average
\item \mbox{[}x\mbox{]} concat
\item \mbox{[} \mbox{]} count
\item \mbox{[} \mbox{]} max
\item \mbox{[} \mbox{]} min
\item \mbox{[} \mbox{]} reduce
\item \mbox{[} \mbox{]} sum
\end{DoxyItemize}\hypertarget{status_autotoc_md15}{}\doxysubsubsection{Backpressure}\label{status_autotoc_md15}

\begin{DoxyItemize}
\item \mbox{[} \mbox{]} backpressure ???
\end{DoxyItemize}\hypertarget{status_autotoc_md16}{}\doxysubsubsection{Error handling}\label{status_autotoc_md16}

\begin{DoxyItemize}
\item \mbox{[} \mbox{]} catch
\item \mbox{[} \mbox{]} retry
\end{DoxyItemize}\hypertarget{status_autotoc_md17}{}\doxysubsubsection{Utility}\label{status_autotoc_md17}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} observe\+\_\+on
\item \mbox{[}x\mbox{]} repeat
\begin{DoxyItemize}
\item \mbox{[} \mbox{]} scheduling (by default trampoline ?)
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} subscribe\+\_\+on
\item \mbox{[} \mbox{]} delay
\item \mbox{[}x\mbox{]} do/tap
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} tap with observer
\item \mbox{[}x\mbox{]} tap with callbacks
\item \mbox{[}x\mbox{]} do\+\_\+on\+\_\+next
\item \mbox{[}x\mbox{]} do\+\_\+on\+\_\+error
\item \mbox{[}x\mbox{]} do\+\_\+on\+\_\+completed
\end{DoxyItemize}
\item \mbox{[} \mbox{]} timeout
\end{DoxyItemize}\hypertarget{status_autotoc_md18}{}\doxysubsubsection{Connectable}\label{status_autotoc_md18}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} publish
\item \mbox{[}x\mbox{]} multicast
\item \mbox{[}x\mbox{]} connect
\item \mbox{[}x\mbox{]} ref\+\_\+count
\item \mbox{[} \mbox{]} replay
\end{DoxyItemize}\hypertarget{status_autotoc_md19}{}\doxysubsection{Subjects}\label{status_autotoc_md19}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} publish\+\_\+subject
\item \mbox{[} \mbox{]} serialized\+\_\+subject
\item \mbox{[} \mbox{]} replay\+\_\+subject
\item \mbox{[} \mbox{]} publish\+\_\+subject
\item \mbox{[} \mbox{]} async\+\_\+subject 
\end{DoxyItemize}